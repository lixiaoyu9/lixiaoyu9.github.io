<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM之内存模型]]></title>
    <url>%2F2020%2F06%2F16%2F11.JVM%E4%B9%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JVM之内存模型 前言 本文主要介绍JVM内存模型和部分参数，文字内容比较多，同时配了图，方便大家理解。 JDK体系结构 JVM介绍 基本概念 JVM 是 Java Virtual Machine 的缩写，它是可运行 Java 代码的假想计算机 ，是一种规范，它的具体实现有HotSpot VM等。 JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，可通过操作系统可以帮我们完成和硬件进行交互的工作。 运行过程 我们知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件， 而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码也就是如下: Java 源文件 —&gt; 编译器 —&gt; 字节码文件 字节码文件 —&gt;JVM —&gt;机器码 每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够跨平台的原因了，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享 。 JVM内存模型 JVM 内存区域主要分为： 线程私有区域（程序计数器、虚拟机栈、本地方法栈）：线程私有数据区域生命周期与线程相同， 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内， 每个线程都与操作系统的本地线程直接映射， 因此这部分内存区域的存/否跟随本地线程的生/死对应)。 线程共享区域（ 堆、方法区）：线程共享区域随虚拟机的启动/关闭而创建/销毁。 直接内存：直接内存并不是 JVM 运行时数据区的一部分， 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存， 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展)， 这样就避免了在 Java堆和 Native 堆中来回复制数据， 因此在一些场景中可以显著提高性能。 先来看一段代码 public&nbsp;class&nbsp;Hello&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;add()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;b&nbsp;=&nbsp;2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;c&nbsp;=&nbsp;a&nbsp;+&nbsp;b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(c);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hello&nbsp;hello&nbsp;=&nbsp;new&nbsp;Hello();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hello.add();&nbsp;&nbsp;&nbsp;&nbsp;}} 那么它在JVM中是怎样的呢？如下图所示 程序计数器 程序计数器是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有” 的内存。 它个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。 如果执行的是native方法，那这个指针就不工作了。 虚拟机栈 是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程（FLFO）。栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。 栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。 虚拟机栈存在的异常： 如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 StackOverflowError （这种错误经常出现在递归中）。 本地方法栈 本地方法栈和虚拟机栈作用类似， 区别是虚拟机栈为执行 Java 方法服务， 而本地方法栈则为Native 方法服务， 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用， 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。 比如说我们现在点开Thread类的源码，会看到它的start0方法带有一个native关键字修饰，而且不存在方法体，这种用native修饰的方法就是本地方法，这是使用C来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。 方法区（又叫非堆） 方法区是JVM的规范，而永久代、元空间是虚拟机VM的实现。在Jdk1.8之前，方法区是用永久代(Permanent Generation)来实现的，用于存储被 JVM 加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据. HotSpot VM把GC分代收集扩展至方法区， 即使用Java堆的永久代来实现方法区， 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存，而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载， 因此收益一般很小)。 运行时常量池（Runtime Constant Pool）是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。 在JDK1.8版本中，已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是metaSpace是不存在于JVM中的，它使用的是本地内存。并有两个参数 MetaspaceSize：初始化元空间大小，控制发生GCMaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。 移除的原因可以大致了解一下： 融合HotSpot VM和JRockit VM而做出的改变，因为JRockit是没有永久代的，不过这也间接性地解决了永久代的OOM问题。 Java堆 是被线程共享的一块内存区域， 创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。 由于现代 VM 采用分代收集算法， 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Young区)和老年代(Old区) 。 image-20200616150540136.png 新生代 用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden 区、 SurvivorFrom、 SurvivorTo三个区。 Eden 区 ：Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。 SurvivorFrom：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。 SurvivorTo：保留了一次 MinorGC 过程中的幸存者。 当我们new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况（并发）。这里JVM的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作TLAB(Thread Local Allocation Buffer)。 这里提到的TLAB属于内存对象分配机制的一种，内存对象分配机制下一篇我们会具体介绍~ 当Eden空间满了之后，会触发一个叫做Minor GC（就是一个发生在年轻代的GC ）的操作，存活下来的对象移动到SurvivorFrom区。SurvivorFrom区满后触发 Minor GC，就会将存活对象移动到SurvivorTo区，此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。经过多次的 Minor GC后仍然存活的对象（这里的存活判断是15次，对应到虚拟机参数为 -XX:TargetSurvivorRatio 。为什么是15，因为HotSpot会在对象头中的标记字段里记录年龄，分配到的空间仅有4位，所以最多只能记录到15）会移动到老年代。 此处提到的对象头(Object-head)，下一篇会具体介绍~ 老年代 老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，期间会停止所有线程等待GC的完成（俗称STW，Stop-The-World）。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。 而且当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xms来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。 以上描述的流程图如下： JVM内存参数设置 Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)： java&nbsp;-Xms2048M&nbsp;-Xmx2048M&nbsp;-Xmn1024M&nbsp;-Xss512K&nbsp;-XX:MetaspaceSize=256M&nbsp;-XX:MaxMetaspaceSize=256M&nbsp;-jar&nbsp;microservice-eureka-server.jar 关于元空间的JVM参数有两个：-XX:MetaspaceSize=N和 -XX:MaxMetaspaceSize=N -XX:MaxMetaspaceSize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小。 -XX:MetaspaceSize： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的-XX:PermSize参数意思不一样，-XX:PermSize代表永久代的初始容量。 由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，对于8G物理内存的机器来说，一般会将这两个值都设置为256M。 结论：尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM之类加载]]></title>
    <url>%2F2020%2F06%2F12%2F10.JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[JVM之类加载 类加载过程 首先看下面这段代码，在执行main函数的时候，先会通过类加载器，将用到的类加载到JVM内存中去 package&nbsp;com.lxy.jvm;public&nbsp;class&nbsp;Hello&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;int&nbsp;a&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;sayHello()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("hello&nbsp;world");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hello&nbsp;hello&nbsp;=&nbsp;new&nbsp;Hello();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hello.sayHello();&nbsp;&nbsp;&nbsp;&nbsp;}} 类加载的流程图如下图所示： image-20200611162108330.png loadClass是加载类到方法区中，这其中包含以下过程 image-20200611164445341.png 加载 在硬盘上查找并通过IO流读入字节码文件（.class），使用到类时才会加载，例如调用类的 main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的 java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 注意这里不一定非得要从一个 .class文件获取，这里既 可以从 ZIP 包中读取(比如从 jar 包和 war 包中读取)，也可以在运行时计算生成(动态代理)， 也可以由其它文件生成(比如将 JSP 文件转换成对应的 Class 类)。 验证 这一阶段的主要目的是为了确保 class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 例如上面提到的Hello类的字节码文件打开是这样的 cafe&nbsp;babe&nbsp;0000&nbsp;0034&nbsp;002c&nbsp;0a00&nbsp;0900&nbsp;1c09001d&nbsp;001e&nbsp;0800&nbsp;1f0a&nbsp;0020&nbsp;0021&nbsp;0700&nbsp;220a0005&nbsp;001c&nbsp;0a00&nbsp;0500&nbsp;2309&nbsp;0005&nbsp;0024&nbsp;07002501&nbsp;0001&nbsp;6101&nbsp;0001&nbsp;4901&nbsp;0006&nbsp;3c69&nbsp;6e69743e&nbsp;0100&nbsp;0328&nbsp;2956&nbsp;0100&nbsp;0443&nbsp;6f64&nbsp;6501000f&nbsp;4c69&nbsp;6e65&nbsp;4e75&nbsp;6d62&nbsp;6572&nbsp;5461&nbsp;626c6501&nbsp;0012&nbsp;4c6f&nbsp;6361&nbsp;6c56&nbsp;6172&nbsp;6961&nbsp;626c6554&nbsp;6162&nbsp;6c65&nbsp;0100&nbsp;0474&nbsp;6869&nbsp;7301&nbsp;00134c63&nbsp;6f6d&nbsp;2f6c&nbsp;7879&nbsp;2f6a&nbsp;766d&nbsp;2f48&nbsp;656c6c6f&nbsp;3b01&nbsp;0008&nbsp;7361&nbsp;7948&nbsp;656c&nbsp;6c6f&nbsp;0100046d&nbsp;6169&nbsp;6e01&nbsp;0016&nbsp;285b&nbsp;4c6a&nbsp;6176&nbsp;612f6c61&nbsp;6e67&nbsp;2f53&nbsp;7472&nbsp;696e&nbsp;673b&nbsp;2956&nbsp;01000461&nbsp;7267&nbsp;7301&nbsp;0013&nbsp;5b4c&nbsp;6a61&nbsp;7661&nbsp;2f6c616e&nbsp;672f&nbsp;5374&nbsp;7269&nbsp;6e67&nbsp;3b01&nbsp;0005&nbsp;68656c6c&nbsp;6f01&nbsp;0008&nbsp;3c63&nbsp;6c69&nbsp;6e69&nbsp;743e&nbsp;01000a53&nbsp;6f75&nbsp;7263&nbsp;6546&nbsp;696c&nbsp;6501&nbsp;000a&nbsp;48656c6c&nbsp;6f2e&nbsp;6a61&nbsp;7661&nbsp;0c00&nbsp;0c00&nbsp;0d07&nbsp;00260c00&nbsp;2700&nbsp;2801&nbsp;000b&nbsp;6865&nbsp;6c6c&nbsp;6f20&nbsp;776f726c&nbsp;6407&nbsp;0029&nbsp;0c00&nbsp;2a00&nbsp;2b01&nbsp;0011&nbsp;636f6d2f&nbsp;6c78&nbsp;792f&nbsp;6a76&nbsp;6d2f&nbsp;4865&nbsp;6c6c&nbsp;6f0c0013&nbsp;000d&nbsp;0c00&nbsp;0a00&nbsp;0b01&nbsp;0010&nbsp;6a61&nbsp;76612f6c&nbsp;616e&nbsp;672f&nbsp;4f62&nbsp;6a65&nbsp;6374&nbsp;0100&nbsp;106a6176&nbsp;612f&nbsp;6c61&nbsp;6e67&nbsp;2f53&nbsp;7973&nbsp;7465&nbsp;6d010003&nbsp;6f75&nbsp;7401&nbsp;0015&nbsp;4c6a&nbsp;6176&nbsp;612f&nbsp;696f2f50&nbsp;7269&nbsp;6e74&nbsp;5374&nbsp;7265&nbsp;616d&nbsp;3b01&nbsp;00136a61&nbsp;7661&nbsp;2f69&nbsp;6f2f&nbsp;5072&nbsp;696e&nbsp;7453&nbsp;74726561&nbsp;6d01&nbsp;0007&nbsp;7072&nbsp;696e&nbsp;746c&nbsp;6e01&nbsp;0015284c&nbsp;6a61&nbsp;7661&nbsp;2f6c&nbsp;616e&nbsp;672f&nbsp;5374&nbsp;72696e67&nbsp;3b29&nbsp;5600&nbsp;2100&nbsp;0500&nbsp;0900&nbsp;0000&nbsp;01000a00&nbsp;0a00&nbsp;0b00&nbsp;0000&nbsp;0400&nbsp;0100&nbsp;0c00&nbsp;0d000100&nbsp;0e00&nbsp;0000&nbsp;2f00&nbsp;0100&nbsp;0100&nbsp;0000&nbsp;052ab700&nbsp;01b1&nbsp;0000&nbsp;0002&nbsp;000f&nbsp;0000&nbsp;0006&nbsp;00010000&nbsp;0007&nbsp;0010&nbsp;0000&nbsp;000c&nbsp;0001&nbsp;0000&nbsp;00050011&nbsp;0012&nbsp;0000&nbsp;0002&nbsp;0013&nbsp;000d&nbsp;0001&nbsp;000e0000&nbsp;0037&nbsp;0002&nbsp;0001&nbsp;0000&nbsp;0009&nbsp;b200&nbsp;021203b6&nbsp;0004&nbsp;b100&nbsp;0000&nbsp;0200&nbsp;0f00&nbsp;0000&nbsp;0a000200&nbsp;0000&nbsp;0c00&nbsp;0800&nbsp;0d00&nbsp;1000&nbsp;0000&nbsp;0c000100&nbsp;0000&nbsp;0900&nbsp;1100&nbsp;1200&nbsp;0000&nbsp;0900&nbsp;14001500&nbsp;0100&nbsp;0e00&nbsp;0000&nbsp;4900&nbsp;0200&nbsp;0200&nbsp;00000dbb&nbsp;0005&nbsp;59b7&nbsp;0006&nbsp;4c2b&nbsp;b700&nbsp;07b1&nbsp;00000002&nbsp;000f&nbsp;0000&nbsp;000e&nbsp;0003&nbsp;0000&nbsp;0010&nbsp;00080011&nbsp;000c&nbsp;0012&nbsp;0010&nbsp;0000&nbsp;0016&nbsp;0002&nbsp;0000000d&nbsp;0016&nbsp;0017&nbsp;0000&nbsp;0008&nbsp;0005&nbsp;0018&nbsp;00120001&nbsp;0008&nbsp;0019&nbsp;000d&nbsp;0001&nbsp;000e&nbsp;0000&nbsp;001d0001&nbsp;0000&nbsp;0000&nbsp;0005&nbsp;04b3&nbsp;0008&nbsp;b100&nbsp;00000100&nbsp;0f00&nbsp;0000&nbsp;0600&nbsp;0100&nbsp;0000&nbsp;0900&nbsp;01001a00&nbsp;0000&nbsp;0200&nbsp;1b 如果将里面的内容修改，则会验证不通过。例如将开头的cafe修改为aaaa 准备 准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。 注意这里的赋初始值，比如 private&nbsp;static&nbsp;int&nbsp;a&nbsp;=&nbsp;1&nbsp;; 变量 a 在准备阶段过后的初始值为 0 而不是 1，将 a 赋值为 1 的指令是程序被编译后，存放于类构造器方法之中。 但是如果加了final关键字，就变为了常量，就会在准备阶段赋值。 解析 将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过程(类加载期间完成) 动态链接是在程序运行期间完成的将符号引用替换为直接引用（例如多态） 初始化 对类的静态变量初始化为指定的值，执行静态代码块。 初始化阶段是执行类构造器client方法的过程。client方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子client方法执行之前，父类 的client方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译 器可以不为这个类生成client方法。 类被加载到方法区中后主要包含 运行时常量池、类型信息、字段信息、方法信息、类加载器的引用、对应class实例的引用等信息。 类加载器的引用：这个类到类加载器实例的引用 对应class实例的引用：类加载器在加载类信息放到方法区中后，会创建一个对应的Class 类型的 对象实例放到堆(Heap)中, 作为开发人员访问方法区中类定义的入口和切入点。 特别注意：主类在运行过程中如果使用到其它类，会逐步加载这些类。 jar包或war包里的类不是一次性全部加载的，是使用到时才加载。 例如如下程序： package&nbsp;com.lxy.jvm;public&nbsp;class&nbsp;Hello&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;int&nbsp;a&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("加载Hello类");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;sayHello()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("hello&nbsp;world");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hello&nbsp;hello&nbsp;=&nbsp;new&nbsp;Hello();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User&nbsp;user&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hello.sayHello();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;class&nbsp;User&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Integer&nbsp;id;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("加载User类");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 只会加载Hello类，User类不会加载 image-20200611180252639.png 类加载器 三种类加载器+自定义加载器 上面的类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器 启动类加载器（BootstrapClassLoader）: 负责加载支撑 JVM 运行的位于 JRE 的lib目录下的核心类库，或通过-Xbootclasspath 参数指定路径中的，且被虚拟机认可(按文件名识别，如 rt.jar)的类。 扩展类加载器（ExtClassLoader）: 负责加载支撑 JVM 运行的位于 JRE 的 lib 目录下的 ext 扩展目录中的，或通过 java.ext.dirs 系统变量指定路径中的类 库。 应用程序类加载器（AppClassLoader）: 负责加载 ClassPath 路径下的类包，主要就是加载自己写的那些类 自定义加载器（UserClassLoader）: 负责加载用户自定义路径下的类包 看下面一段代码： package&nbsp;com.lxy.jvm;import&nbsp;com.sun.crypto.provider.DESKeyFactory;public&nbsp;class&nbsp;JdkClassLoaderTest&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(String.class.getClassLoader());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(DESKeyFactory.class.getClassLoader());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(JdkClassLoaderTest.class.getClassLoader());&nbsp;&nbsp;&nbsp;&nbsp;}} 猜想一下会打印什么？ nullsun.misc.Launcher$ExtClassLoader@29453f44sun.misc.Launcher$AppClassLoader@18b4aac2 因为 String 属于 JDK 核心包在 rt.jar 下，所以他的类加载器是启动类加载器，但是启动类加载器是 C++ 实现的，此处是 null. 因为 DESKeyFactory 在 jre\lib\ext 下，所以他的类加载器是扩展类加载器 ExtClassLoader. 因为 JdkClassLoaderTest 是我们自己定义的类，所以他的类加载器是 AppClassLoader. 类加载器初始化过程 参见类运行加载全过程图可知其中会创建JVM启动器实例 sun.misc.Launcher 在Launcher构造方法内部，其创建了两个类加载器，分别是sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应用类加载器)。 image-20200612094737722.png JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们的应用程序。 public&nbsp;ClassLoader&nbsp;getClassLoader()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;返回了this.loader&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this.loader;} this.loader是在Launcher构造方法里赋值的 public&nbsp;Launcher()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Launcher.ExtClassLoader&nbsp;var1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;构造扩展类加载器，在构造的过程中将其父加载器设置为null(可以自行查看构造代码，很简单)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var1&nbsp;=&nbsp;Launcher.ExtClassLoader.getExtClassLoader();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;var10)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;InternalError("Could&nbsp;not&nbsp;create&nbsp;extension&nbsp;class&nbsp;loader",&nbsp;var10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;可以看到&nbsp;this.loader的值为AppClassLoader&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;构造应用类加载器，在构造的过程中将其父加载器设置为ExtClassLoader&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.loader&nbsp;=&nbsp;Launcher.AppClassLoader.getAppClassLoader(var1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;var9)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;InternalError("Could&nbsp;not&nbsp;create&nbsp;application&nbsp;class&nbsp;loader",&nbsp;var9);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.currentThread().setContextClassLoader(this.loader);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;省略部分代码...} 双亲委派机制 JVM类加载器是有亲子层级结构的 image-20200612094527506.png 双亲委派：加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并加载目标类 。 从源码看双亲委派 双亲委派的实现其实并不复杂，其实就是一个递归，我们一起来看一下ClassLoader里的loadClass方法： //&nbsp;ClassLoader的loadClass方法，里面实现了双亲委派机制protected&nbsp;Class&lt;?&gt;&nbsp;loadClass(String&nbsp;name,&nbsp;boolean&nbsp;resolve)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;ClassNotFoundException&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(getClassLoadingLock(name))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;First,&nbsp;check&nbsp;if&nbsp;the&nbsp;class&nbsp;has&nbsp;already&nbsp;been&nbsp;loaded&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;检查当前类加载器是否已经加载了该类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class&lt;?&gt;&nbsp;c&nbsp;=&nbsp;findLoadedClass(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;t0&nbsp;=&nbsp;System.nanoTime();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(parent&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;委托父加载器加载&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;parent.loadClass(name,&nbsp;false);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//若没有父加载器，则委托启动类加载器加载&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;findBootstrapClassOrNull(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(ClassNotFoundException&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;ClassNotFoundException&nbsp;thrown&nbsp;if&nbsp;class&nbsp;not&nbsp;found&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;from&nbsp;the&nbsp;non-null&nbsp;parent&nbsp;class&nbsp;loader&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;If&nbsp;still&nbsp;not&nbsp;found,&nbsp;then&nbsp;invoke&nbsp;findClass&nbsp;in&nbsp;order&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;to&nbsp;find&nbsp;the&nbsp;class.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;t1&nbsp;=&nbsp;System.nanoTime();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;父加载器都加载失败，则调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;findClass(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;this&nbsp;is&nbsp;the&nbsp;defining&nbsp;class&nbsp;loader;&nbsp;record&nbsp;the&nbsp;stats&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sun.misc.PerfCounter.getParentDelegationTime().addTime(t1&nbsp;-&nbsp;t0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sun.misc.PerfCounter.getFindClasses().increment();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(resolve)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolveClass(c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;} 当我们点开findClass()方法，是在ClassLoader类里，发现里面没有实现？what？ protected&nbsp;Class&lt;?&gt;&nbsp;findClass(String&nbsp;name)&nbsp;throws&nbsp;ClassNotFoundException&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;ClassNotFoundException(name);} 然后查看类结构 image-20200612094716253.png image-20200612094359943.png 发现在URLClassLoader中，重写了findClass()方法 protected&nbsp;Class&lt;?&gt;&nbsp;findClass(final&nbsp;String&nbsp;name)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throws&nbsp;ClassNotFoundException&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;Class&lt;?&gt;&nbsp;result;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;AccessController.doPrivileged(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new&nbsp;PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Class&lt;?&gt;&nbsp;run()&nbsp;throws&nbsp;ClassNotFoundException&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;path&nbsp;=&nbsp;name.replace('.',&nbsp;'/').concat(".class");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Resource&nbsp;res&nbsp;=&nbsp;ucp.getResource(path,&nbsp;false);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(res&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;defineClass(name,&nbsp;res);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IOException&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;ClassNotFoundException(name,&nbsp;e);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;acc);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(java.security.PrivilegedActionException&nbsp;pae)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;(ClassNotFoundException)&nbsp;pae.getException();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(result&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;ClassNotFoundException(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;&nbsp;&nbsp;&nbsp;&nbsp;} 在URLClassLoader.findClass()中，调用了defineClass完成类的加载。 总结一下双亲委派类加载的过程： 首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。 如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）；如果有父加载器调用bootstrap类加载器来加载。 如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。 为什么要双亲委派？ 沙箱安全机制：自己写的java.lang.String类不会被加载，这样便可以防止核心API库被随意篡改。 避免类的重复加载：当父类已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性 。比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。 来看一个例子： package&nbsp;java.lang;public&nbsp;class&nbsp;String&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("加载自定义String类");&nbsp;&nbsp;&nbsp;&nbsp;}} 定义了一个java.lang.String类，但是却无法运行，触发了沙箱安全机制 打破双亲委派机制 实现一个自定义类加载器 自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法，一个是loadClass(String, boolean)，实现了双亲委派机制，还有一个方法是findClass，默认实现是空方法，所以我们自定义类加载器主要是重写findClass方法。 package&nbsp;com.lxy.jvm;import&nbsp;java.io.FileInputStream;import&nbsp;java.lang.reflect.Method;public&nbsp;class&nbsp;MyClassLoaderTest&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;class&nbsp;MyClassLoader&nbsp;extends&nbsp;ClassLoader&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;classPath;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;MyClassLoader(String&nbsp;classPath)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.classPath&nbsp;=&nbsp;classPath;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;Class&lt;?&gt;&nbsp;findClass(String&nbsp;name)&nbsp;throws&nbsp;ClassNotFoundException&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]&nbsp;data&nbsp;=&nbsp;loadByte(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;defineClass(name,&nbsp;data,&nbsp;0,&nbsp;data.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;ClassNotFoundException();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;byte[]&nbsp;loadByte(String&nbsp;name)&nbsp;throws&nbsp;Exception&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;name.replaceAll("\\.",&nbsp;"/");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FileInputStream&nbsp;fis&nbsp;=&nbsp;new&nbsp;FileInputStream(classPath&nbsp;+&nbsp;"/"&nbsp;+&nbsp;name&nbsp;+&nbsp;".class");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;len&nbsp;=&nbsp;fis.available();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]&nbsp;data&nbsp;=&nbsp;new&nbsp;byte[len];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fis.read(data);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fis.close();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;data;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父加载器设置为应用程序类加载器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AppClassLoader（源码很简单，可以自行查看）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MyClassLoader&nbsp;classLoader&nbsp;=&nbsp;new&nbsp;MyClassLoader("E:/test");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//E盘创建&nbsp;test/com/lxy/jvm&nbsp;几级目录，将People.class丢入该目录&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class&nbsp;clazz&nbsp;=&nbsp;classLoader.loadClass("com.lxy.jvm.People");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;obj&nbsp;=&nbsp;clazz.newInstance();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;method&nbsp;=&nbsp;clazz.getDeclaredMethod("say",&nbsp;null);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method.setAccessible(true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method.invoke(obj,&nbsp;null);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(clazz.getClassLoader().getClass().getName());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} package&nbsp;com.lxy.jvm;public&nbsp;class&nbsp;People&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Integer&nbsp;id;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;People()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;say()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("I‘m&nbsp;tom");&nbsp;&nbsp;&nbsp;&nbsp;}} 运行结果： I‘m&nbsp;tomcom.lxy.jvm.MyClassLoaderTest$MyClassLoader 已经使用了自定义加载器MyClassLoader加载People 通过自定义类加载器简单实现打破双亲委派 打破双亲委派需要重写loadClass方法 此处仅为简单demo实现，不可模仿 @Overrideprotected&nbsp;Class&lt;?&gt;&nbsp;loadClass(String&nbsp;name,&nbsp;boolean&nbsp;resolve)&nbsp;throws&nbsp;ClassNotFoundException&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(getClassLoadingLock(name))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;First,&nbsp;check&nbsp;if&nbsp;the&nbsp;class&nbsp;has&nbsp;already&nbsp;been&nbsp;loaded&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class&lt;?&gt;&nbsp;c&nbsp;=&nbsp;findLoadedClass(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(c&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;如果是我自己的类，就走我自己的加载器&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!name.startsWith("com.lxy"))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;this.getParent().loadClass(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;=&nbsp;findClass(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;t1&nbsp;=&nbsp;System.nanoTime();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sun.misc.PerfCounter.getFindClasses().increment();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(resolve)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolveClass(c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;} 如何验证呢？ 我们在项目中创建一个People类，同时E盘下也有一个People.class。 先把重写的方法loadClass注释，运行程序结果如下： I‘m&nbsp;tomsun.misc.Launcher$AppClassLoader 因为存在双亲委派，所以自定义类加载器会委派AppClassLoader加载，恰好项目路径下有People类，则由AppClassLoader直接加载。 将方法loadClass注释放开，再次运行 I‘m&nbsp;tomcom.lxy.jvm.MyClassLoaderTest$MyClassLoader 可见，由MyClassLoader加载了People，打破了双亲委派。 为什么不用String类去尝试，而采用People类呢？ 有心的小伙伴可以去试试，如果用String类去尝试打破，则会触发安全机制 java.lang.SecurityException: Prohibited package name: java.lang JVM可不会让你改它的核心包的，如果随便能改，那就乱套了。。 Tomcat打破双亲委派 首先思考一下：Tomcat 如果使用默认的双亲委派类加载机制行不行？ 一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 比如不同war包应用引入了不同的spring版本，这样实现就能加载各自的spring版本 如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。 所以Tomcat每个webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器，打破了双亲委派机制。 有兴趣的小伙伴，可以去看下Tomcat打破双亲委派的实现~ 本文到这里就结束了，感觉大家的阅读。 JVM类加载，你学会了么？]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员不得不知道的设计模式]]></title>
    <url>%2F2020%2F03%2F15%2F9.%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、概述 设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。 拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。 二、创建型 1. 单例（Singleton） Intent 确保一个类只有一个实例，并提供该实例的全局访问点。 Class Diagram 使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。 私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。 img Implementation Ⅰ 懒汉式-线程不安全 以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。 这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 if (uniqueInstance == null) ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 uniqueInstance = new Singleton(); 语句，这将导致实例化多次 uniqueInstance。 public&nbsp;class&nbsp;Singleton&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Singleton&nbsp;uniqueInstance;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getUniqueInstance()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(uniqueInstance&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uniqueInstance&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;uniqueInstance;&nbsp;&nbsp;&nbsp;&nbsp;}} Ⅱ 饿汉式-线程安全 线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。 但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。 private&nbsp;static&nbsp;Singleton&nbsp;uniqueInstance&nbsp;=&nbsp;new&nbsp;Singleton(); Ⅲ 懒汉式-线程安全 只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。 但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。 public&nbsp;static&nbsp;synchronized&nbsp;Singleton&nbsp;getUniqueInstance()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(uniqueInstance&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uniqueInstance&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;uniqueInstance;} Ⅳ 双重校验锁-线程安全 uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。 双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。 public&nbsp;class&nbsp;Singleton&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;volatile&nbsp;static&nbsp;Singleton&nbsp;uniqueInstance;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getUniqueInstance()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(uniqueInstance&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(Singleton.class)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(uniqueInstance&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uniqueInstance&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;uniqueInstance;&nbsp;&nbsp;&nbsp;&nbsp;}} 考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 uniqueInstance = new Singleton(); 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。 if&nbsp;(uniqueInstance&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(Singleton.class)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uniqueInstance&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp;&nbsp;&nbsp;}} uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行： 为 uniqueInstance 分配内存空间 初始化 uniqueInstance 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1&gt;3&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 Ⅴ 静态内部类实现 当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。 这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。 public&nbsp;class&nbsp;Singleton&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;class&nbsp;SingletonHolder&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;Singleton&nbsp;INSTANCE&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getUniqueInstance()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;SingletonHolder.INSTANCE;&nbsp;&nbsp;&nbsp;&nbsp;}} Ⅵ 枚举实现 public&nbsp;enum&nbsp;Singleton&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;INSTANCE;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;objName;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getObjName()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;objName;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setObjName(String&nbsp;objName)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.objName&nbsp;=&nbsp;objName;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;单例测试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singleton&nbsp;firstSingleton&nbsp;=&nbsp;Singleton.INSTANCE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstSingleton.setObjName("firstName");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(firstSingleton.getObjName());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singleton&nbsp;secondSingleton&nbsp;=&nbsp;Singleton.INSTANCE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secondSingleton.setObjName("secondName");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(firstSingleton.getObjName());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(secondSingleton.getObjName());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;反射获取实例测试&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singleton[]&nbsp;enumConstants&nbsp;=&nbsp;Singleton.class.getEnumConstants();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Singleton&nbsp;enumConstant&nbsp;:&nbsp;enumConstants)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(enumConstant.getObjName());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。 该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。 Examples Logger Classes Configuration Classes Accesing resources in shared mode Factories implemented as Singletons JDK java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager() 2. 简单工厂（Simple Factory） Intent 在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。 Class Diagram 简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。 这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。 img Implementation public&nbsp;interface&nbsp;Product&nbsp;{}public&nbsp;class&nbsp;ConcreteProduct&nbsp;implements&nbsp;Product&nbsp;{}public&nbsp;class&nbsp;ConcreteProduct1&nbsp;implements&nbsp;Product&nbsp;{}public&nbsp;class&nbsp;ConcreteProduct2&nbsp;implements&nbsp;Product&nbsp;{} 以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。 public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;type&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Product&nbsp;product;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(type&nbsp;==&nbsp;1)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product&nbsp;=&nbsp;new&nbsp;ConcreteProduct1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(type&nbsp;==&nbsp;2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product&nbsp;=&nbsp;new&nbsp;ConcreteProduct2();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product&nbsp;=&nbsp;new&nbsp;ConcreteProduct();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;with&nbsp;the&nbsp;product&nbsp;&nbsp;&nbsp;&nbsp;}} 以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。 public&nbsp;class&nbsp;SimpleFactory&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Product&nbsp;createProduct(int&nbsp;type)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(type&nbsp;==&nbsp;1)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ConcreteProduct1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;if&nbsp;(type&nbsp;==&nbsp;2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ConcreteProduct2();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ConcreteProduct();&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SimpleFactory&nbsp;simpleFactory&nbsp;=&nbsp;new&nbsp;SimpleFactory();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Product&nbsp;product&nbsp;=&nbsp;simpleFactory.createProduct(1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;with&nbsp;the&nbsp;product&nbsp;&nbsp;&nbsp;&nbsp;}} 3. 工厂方法（Factory Method） Intent 定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。 Class Diagram 在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。 下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。 img Implementation public&nbsp;abstract&nbsp;class&nbsp;Factory&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;public&nbsp;Product&nbsp;factoryMethod();&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doSomething()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Product&nbsp;product&nbsp;=&nbsp;factoryMethod();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;with&nbsp;the&nbsp;product&nbsp;&nbsp;&nbsp;&nbsp;}}public&nbsp;class&nbsp;ConcreteFactory&nbsp;extends&nbsp;Factory&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Product&nbsp;factoryMethod()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ConcreteProduct();&nbsp;&nbsp;&nbsp;&nbsp;}}public&nbsp;class&nbsp;ConcreteFactory1&nbsp;extends&nbsp;Factory&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Product&nbsp;factoryMethod()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ConcreteProduct1();&nbsp;&nbsp;&nbsp;&nbsp;}}public&nbsp;class&nbsp;ConcreteFactory2&nbsp;extends&nbsp;Factory&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Product&nbsp;factoryMethod()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ConcreteProduct2();&nbsp;&nbsp;&nbsp;&nbsp;}} JDK java.util.Calendar java.util.ResourceBundle java.text.NumberFormat java.nio.charset.Charset java.net.URLStreamHandlerFactory java.util.EnumSet javax.xml.bind.JAXBContext 4. 抽象工厂（Abstract Factory） Intent 提供一个接口，用于创建 相关的对象家族 。 Class Diagram 抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。 抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。 至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。 从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。 img Implementation public&nbsp;class&nbsp;AbstractProductA&nbsp;{}public&nbsp;class&nbsp;AbstractProductB&nbsp;{}public&nbsp;class&nbsp;ProductA1&nbsp;extends&nbsp;AbstractProductA&nbsp;{}public&nbsp;class&nbsp;ProductA2&nbsp;extends&nbsp;AbstractProductA&nbsp;{}public&nbsp;class&nbsp;ProductB1&nbsp;extends&nbsp;AbstractProductB&nbsp;{}public&nbsp;class&nbsp;ProductB2&nbsp;extends&nbsp;AbstractProductB&nbsp;{}public&nbsp;abstract&nbsp;class&nbsp;AbstractFactory&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;AbstractProductA&nbsp;createProductA();&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;AbstractProductB&nbsp;createProductB();}public&nbsp;class&nbsp;ConcreteFactory1&nbsp;extends&nbsp;AbstractFactory&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;AbstractProductA&nbsp;createProductA()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ProductA1();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;AbstractProductB&nbsp;createProductB()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ProductB1();&nbsp;&nbsp;&nbsp;&nbsp;}}public&nbsp;class&nbsp;ConcreteFactory2&nbsp;extends&nbsp;AbstractFactory&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;AbstractProductA&nbsp;createProductA()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ProductA2();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;AbstractProductB&nbsp;createProductB()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ProductB2();&nbsp;&nbsp;&nbsp;&nbsp;}}public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractFactory&nbsp;abstractFactory&nbsp;=&nbsp;new&nbsp;ConcreteFactory1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractProductA&nbsp;productA&nbsp;=&nbsp;abstractFactory.createProductA();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractProductB&nbsp;productB&nbsp;=&nbsp;abstractFactory.createProductB();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;something&nbsp;with&nbsp;productA&nbsp;and&nbsp;productB&nbsp;&nbsp;&nbsp;&nbsp;}} JDK javax.xml.parsers.DocumentBuilderFactory javax.xml.transform.TransformerFactory javax.xml.xpath.XPathFactory 5. 生成器（Builder） Intent 封装一个对象的构造过程，并允许按步骤构造。 Class Diagram img Implementation 以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。 public&nbsp;class&nbsp;AbstractStringBuilder&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;char[]&nbsp;value;&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;int&nbsp;count;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;AbstractStringBuilder(int&nbsp;capacity)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;new&nbsp;char[capacity];&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;AbstractStringBuilder&nbsp;append(char&nbsp;c)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ensureCapacityInternal(count&nbsp;+&nbsp;1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value[count++]&nbsp;=&nbsp;c;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;this;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;void&nbsp;ensureCapacityInternal(int&nbsp;minimumCapacity)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;overflow-conscious&nbsp;code&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(minimumCapacity&nbsp;-&nbsp;value.length&nbsp;&gt;&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expandCapacity(minimumCapacity);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;expandCapacity(int&nbsp;minimumCapacity)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;newCapacity&nbsp;=&nbsp;value.length&nbsp;*&nbsp;2&nbsp;+&nbsp;2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(newCapacity&nbsp;-&nbsp;minimumCapacity&nbsp;&lt;&nbsp;0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newCapacity&nbsp;=&nbsp;minimumCapacity;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(newCapacity&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(minimumCapacity&nbsp;&lt;&nbsp;0)&nbsp;//&nbsp;overflow&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;OutOfMemoryError();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newCapacity&nbsp;=&nbsp;Integer.MAX_VALUE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;=&nbsp;Arrays.copyOf(value,&nbsp;newCapacity);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;StringBuilder&nbsp;extends&nbsp;AbstractStringBuilder&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;StringBuilder()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(16);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;toString()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Create&nbsp;a&nbsp;copy,&nbsp;don't&nbsp;share&nbsp;the&nbsp;array&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;String(value,&nbsp;0,&nbsp;count);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuilder&nbsp;sb&nbsp;=&nbsp;new&nbsp;StringBuilder();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;int&nbsp;count&nbsp;=&nbsp;26;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;count;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sb.append((char)&nbsp;('a'&nbsp;+&nbsp;i));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(sb.toString());&nbsp;&nbsp;&nbsp;&nbsp;}} JDK java.lang.StringBuilder java.nio.ByteBuffer java.lang.StringBuffer java.lang.Appendable Apache Camel builders 6. 原型模式（Prototype） Intent 使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。 Class Diagram img Implementation public&nbsp;abstract&nbsp;class&nbsp;Prototype&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;Prototype&nbsp;myClone();} public&nbsp;class&nbsp;ConcretePrototype&nbsp;extends&nbsp;Prototype&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;filed;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ConcretePrototype(String&nbsp;filed)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.filed&nbsp;=&nbsp;filed;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;Prototype&nbsp;myClone()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ConcretePrototype(filed);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;toString()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;filed;&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prototype&nbsp;prototype&nbsp;=&nbsp;new&nbsp;ConcretePrototype("abc");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prototype&nbsp;clone&nbsp;=&nbsp;prototype.myClone();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(clone.toString());&nbsp;&nbsp;&nbsp;&nbsp;}} abc JDK java.lang.Object#clone() 三、行为型 1. 责任链（Chain Of Responsibility） Intent 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。 Class Diagram Handler：定义处理请求的接口，并且实现后继链（successor） img Implementation public&nbsp;abstract&nbsp;class&nbsp;Handler&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;Handler&nbsp;successor;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Handler(Handler&nbsp;successor)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.successor&nbsp;=&nbsp;successor;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;abstract&nbsp;void&nbsp;handleRequest(Request&nbsp;request);} public&nbsp;class&nbsp;ConcreteHandler1&nbsp;extends&nbsp;Handler&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ConcreteHandler1(Handler&nbsp;successor)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(successor);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;handleRequest(Request&nbsp;request)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(request.getType()&nbsp;==&nbsp;RequestType.TYPE1)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(request.getName()&nbsp;+&nbsp;"&nbsp;is&nbsp;handle&nbsp;by&nbsp;ConcreteHandler1");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(successor&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;successor.handleRequest(request);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;ConcreteHandler2&nbsp;extends&nbsp;Handler&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ConcreteHandler2(Handler&nbsp;successor)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(successor);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;void&nbsp;handleRequest(Request&nbsp;request)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(request.getType()&nbsp;==&nbsp;RequestType.TYPE2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(request.getName()&nbsp;+&nbsp;"&nbsp;is&nbsp;handle&nbsp;by&nbsp;ConcreteHandler2");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(successor&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;successor.handleRequest(request);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Request&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;RequestType&nbsp;type;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Request(RequestType&nbsp;type,&nbsp;String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.type&nbsp;=&nbsp;type;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;RequestType&nbsp;getType()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;type;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getName()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;enum&nbsp;RequestType&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;TYPE1,&nbsp;TYPE2} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handler&nbsp;handler1&nbsp;=&nbsp;new&nbsp;ConcreteHandler1(null);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Handler&nbsp;handler2&nbsp;=&nbsp;new&nbsp;ConcreteHandler2(handler1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Request&nbsp;request1&nbsp;=&nbsp;new&nbsp;Request(RequestType.TYPE1,&nbsp;"request1");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler2.handleRequest(request1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Request&nbsp;request2&nbsp;=&nbsp;new&nbsp;Request(RequestType.TYPE2,&nbsp;"request2");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handler2.handleRequest(request2);&nbsp;&nbsp;&nbsp;&nbsp;}} request1&nbsp;is&nbsp;handle&nbsp;by&nbsp;ConcreteHandler1request2&nbsp;is&nbsp;handle&nbsp;by&nbsp;ConcreteHandler2 JDK [java.util.logging.Logger#log()](http://docs.oracle.com/javase/8/docs/api/java/util/logging/Logger.html#log(java.util.logging.Level, java.lang.String)) Apache Commons Chain javax.servlet.Filter#doFilter() 2. 命令（Command） Intent 将命令封装成对象中，具有以下作用： 使用命令来参数化其它对象 将命令放入队列中进行排队 将命令的操作记录到日志中 支持可撤销的操作 Class Diagram Command：命令 Receiver：命令接收者，也就是命令真正的执行者 Invoker：通过它来调用命令 Client：可以设置命令与命令的接收者 img Implementation 设计一个遥控器，可以控制电灯开关。 img public&nbsp;interface&nbsp;Command&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;execute();} public&nbsp;class&nbsp;LightOnCommand&nbsp;implements&nbsp;Command&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Light&nbsp;light;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;LightOnCommand(Light&nbsp;light)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.light&nbsp;=&nbsp;light;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;execute()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;light.on();&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;LightOffCommand&nbsp;implements&nbsp;Command&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Light&nbsp;light;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;LightOffCommand(Light&nbsp;light)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.light&nbsp;=&nbsp;light;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;execute()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;light.off();&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Light&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;on()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Light&nbsp;is&nbsp;on!");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;off()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Light&nbsp;is&nbsp;off!");&nbsp;&nbsp;&nbsp;&nbsp;}} /**&nbsp;*&nbsp;遥控器&nbsp;*/public&nbsp;class&nbsp;Invoker&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Command[]&nbsp;onCommands;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Command[]&nbsp;offCommands;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;int&nbsp;slotNum&nbsp;=&nbsp;7;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Invoker()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.onCommands&nbsp;=&nbsp;new&nbsp;Command[slotNum];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.offCommands&nbsp;=&nbsp;new&nbsp;Command[slotNum];&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setOnCommand(Command&nbsp;command,&nbsp;int&nbsp;slot)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onCommands[slot]&nbsp;=&nbsp;command;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setOffCommand(Command&nbsp;command,&nbsp;int&nbsp;slot)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offCommands[slot]&nbsp;=&nbsp;command;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onButtonWasPushed(int&nbsp;slot)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;onCommands[slot].execute();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;offButtonWasPushed(int&nbsp;slot)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;offCommands[slot].execute();&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Invoker&nbsp;invoker&nbsp;=&nbsp;new&nbsp;Invoker();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Light&nbsp;light&nbsp;=&nbsp;new&nbsp;Light();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Command&nbsp;lightOnCommand&nbsp;=&nbsp;new&nbsp;LightOnCommand(light);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Command&nbsp;lightOffCommand&nbsp;=&nbsp;new&nbsp;LightOffCommand(light);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invoker.setOnCommand(lightOnCommand,&nbsp;0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invoker.setOffCommand(lightOffCommand,&nbsp;0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invoker.onButtonWasPushed(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invoker.offButtonWasPushed(0);&nbsp;&nbsp;&nbsp;&nbsp;}} JDK java.lang.Runnable Netflix Hystrix javax.swing.Action 3. 解释器（Interpreter） Intent 为语言创建解释器，通常由语言的语法和语法分析来定义。 Class Diagram TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。 Context：上下文，包含解释器之外的一些全局信息。 img Implementation 以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。 例如一颗解析树为 D And (A Or (B C))，文本 “D A” 满足该解析树定义的规则。 这里的 Context 指的是 String。 public&nbsp;abstract&nbsp;class&nbsp;Expression&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;boolean&nbsp;interpret(String&nbsp;str);} public&nbsp;class&nbsp;TerminalExpression&nbsp;extends&nbsp;Expression&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;literal&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;TerminalExpression(String&nbsp;str)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;literal&nbsp;=&nbsp;str;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;interpret(String&nbsp;str)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringTokenizer&nbsp;st&nbsp;=&nbsp;new&nbsp;StringTokenizer(str);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(st.hasMoreTokens())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;test&nbsp;=&nbsp;st.nextToken();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(test.equals(literal))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;AndExpression&nbsp;extends&nbsp;Expression&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Expression&nbsp;expression1&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Expression&nbsp;expression2&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;AndExpression(Expression&nbsp;expression1,&nbsp;Expression&nbsp;expression2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.expression1&nbsp;=&nbsp;expression1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.expression2&nbsp;=&nbsp;expression2;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;interpret(String&nbsp;str)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;expression1.interpret(str)&nbsp;&amp;&amp;&nbsp;expression2.interpret(str);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;OrExpression&nbsp;extends&nbsp;Expression&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Expression&nbsp;expression1&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Expression&nbsp;expression2&nbsp;=&nbsp;null;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;OrExpression(Expression&nbsp;expression1,&nbsp;Expression&nbsp;expression2)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.expression1&nbsp;=&nbsp;expression1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.expression2&nbsp;=&nbsp;expression2;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;interpret(String&nbsp;str)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;expression1.interpret(str)&nbsp;||&nbsp;expression2.interpret(str);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;构建解析树&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Expression&nbsp;buildInterpreterTree()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Literal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;terminal1&nbsp;=&nbsp;new&nbsp;TerminalExpression("A");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;terminal2&nbsp;=&nbsp;new&nbsp;TerminalExpression("B");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;terminal3&nbsp;=&nbsp;new&nbsp;TerminalExpression("C");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;terminal4&nbsp;=&nbsp;new&nbsp;TerminalExpression("D");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;B&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;alternation1&nbsp;=&nbsp;new&nbsp;OrExpression(terminal2,&nbsp;terminal3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;A&nbsp;Or&nbsp;(B&nbsp;C)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;alternation2&nbsp;=&nbsp;new&nbsp;OrExpression(terminal1,&nbsp;alternation1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;D&nbsp;And&nbsp;(A&nbsp;Or&nbsp;(B&nbsp;C))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;AndExpression(terminal4,&nbsp;alternation2);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;define&nbsp;=&nbsp;buildInterpreterTree();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;context1&nbsp;=&nbsp;"D&nbsp;A";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;context2&nbsp;=&nbsp;"A&nbsp;B";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(define.interpret(context1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(define.interpret(context2));&nbsp;&nbsp;&nbsp;&nbsp;}} truefalse JDK java.util.Pattern java.text.Normalizer All subclasses of java.text.Format javax.el.ELResolver 4. 迭代器（Iterator） Intent 提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。 Class Diagram Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator； Iterator 主要定义了 hasNext() 和 next() 方法。 Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。 img Implementation public&nbsp;interface&nbsp;Aggregate&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Iterator&nbsp;createIterator();} public&nbsp;class&nbsp;ConcreteAggregate&nbsp;implements&nbsp;Aggregate&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Integer[]&nbsp;items;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ConcreteAggregate()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items&nbsp;=&nbsp;new&nbsp;Integer[10];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;items.length;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items[i]&nbsp;=&nbsp;i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Iterator&nbsp;createIterator()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;ConcreteIterator&lt;Integer&gt;(items);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;interface&nbsp;Iterator&lt;Item&gt;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Item&nbsp;next();&nbsp;&nbsp;&nbsp;&nbsp;boolean&nbsp;hasNext();} public&nbsp;class&nbsp;ConcreteIterator&lt;Item&gt;&nbsp;implements&nbsp;Iterator&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Item[]&nbsp;items;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;position&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ConcreteIterator(Item[]&nbsp;items)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.items&nbsp;=&nbsp;items;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Object&nbsp;next()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;items[position++];&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;hasNext()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;position&nbsp;&lt;&nbsp;items.length;&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Aggregate&nbsp;aggregate&nbsp;=&nbsp;new&nbsp;ConcreteAggregate();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Iterator&lt;Integer&gt;&nbsp;iterator&nbsp;=&nbsp;aggregate.createIterator();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(iterator.hasNext())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} JDK java.util.Iterator java.util.Enumeration 5. 中介者（Mediator） Intent 集中相关对象之间复杂的沟通和控制方式。 Class Diagram Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。 Colleague：同事，相关对象 img Implementation Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构： img 使用中介者模式可以将复杂的依赖结构变成星形结构： img public&nbsp;abstract&nbsp;class&nbsp;Colleague&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;void&nbsp;onEvent(Mediator&nbsp;mediator);} public&nbsp;class&nbsp;Alarm&nbsp;extends&nbsp;Colleague&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onEvent(Mediator&nbsp;mediator)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mediator.doEvent("alarm");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doAlarm()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("doAlarm()");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;CoffeePot&nbsp;extends&nbsp;Colleague&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onEvent(Mediator&nbsp;mediator)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mediator.doEvent("coffeePot");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doCoffeePot()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("doCoffeePot()");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Calender&nbsp;extends&nbsp;Colleague&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onEvent(Mediator&nbsp;mediator)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mediator.doEvent("calender");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doCalender()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("doCalender()");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Sprinkler&nbsp;extends&nbsp;Colleague&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;onEvent(Mediator&nbsp;mediator)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mediator.doEvent("sprinkler");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doSprinkler()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("doSprinkler()");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;abstract&nbsp;class&nbsp;Mediator&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;void&nbsp;doEvent(String&nbsp;eventType);} public&nbsp;class&nbsp;ConcreteMediator&nbsp;extends&nbsp;Mediator&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Alarm&nbsp;alarm;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;CoffeePot&nbsp;coffeePot;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Calender&nbsp;calender;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Sprinkler&nbsp;sprinkler;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ConcreteMediator(Alarm&nbsp;alarm,&nbsp;CoffeePot&nbsp;coffeePot,&nbsp;Calender&nbsp;calender,&nbsp;Sprinkler&nbsp;sprinkler)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alarm&nbsp;=&nbsp;alarm;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.coffeePot&nbsp;=&nbsp;coffeePot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.calender&nbsp;=&nbsp;calender;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sprinkler&nbsp;=&nbsp;sprinkler;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doEvent(String&nbsp;eventType)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch&nbsp;(eventType)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;"alarm":&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doAlarmEvent();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;"coffeePot":&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doCoffeePotEvent();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case&nbsp;"calender":&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doCalenderEvent();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;doSprinklerEvent();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doAlarmEvent()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alarm.doAlarm();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coffeePot.doCoffeePot();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calender.doCalender();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sprinkler.doSprinkler();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doCoffeePotEvent()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doCalenderEvent()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doSprinklerEvent()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alarm&nbsp;alarm&nbsp;=&nbsp;new&nbsp;Alarm();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CoffeePot&nbsp;coffeePot&nbsp;=&nbsp;new&nbsp;CoffeePot();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calender&nbsp;calender&nbsp;=&nbsp;new&nbsp;Calender();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sprinkler&nbsp;sprinkler&nbsp;=&nbsp;new&nbsp;Sprinkler();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mediator&nbsp;mediator&nbsp;=&nbsp;new&nbsp;ConcreteMediator(alarm,&nbsp;coffeePot,&nbsp;calender,&nbsp;sprinkler);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;闹钟事件到达，调用中介者就可以操作相关对象&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;alarm.onEvent(mediator);&nbsp;&nbsp;&nbsp;&nbsp;}} doAlarm()doCoffeePot()doCalender()doSprinkler() JDK All scheduleXXX() methods of java.util.Timer java.util.concurrent.Executor#execute() submit() and invokeXXX() methods of java.util.concurrent.ExecutorService scheduleXXX() methods of java.util.concurrent.ScheduledExecutorService java.lang.reflect.Method#invoke() 6. 备忘录（Memento） Intent 在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。 Class Diagram Originator：原始对象 Caretaker：负责保存好备忘录 Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。 img Implementation 以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。 实现参考：Memento Pattern - Calculator Example - Java Sourcecode /**&nbsp;*&nbsp;Originator&nbsp;Interface&nbsp;*/public&nbsp;interface&nbsp;Calculator&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Create&nbsp;Memento&nbsp;&nbsp;&nbsp;&nbsp;PreviousCalculationToCareTaker&nbsp;backupLastCalculation();&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;setMemento&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;restorePreviousCalculation(PreviousCalculationToCareTaker&nbsp;memento);&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;getCalculationResult();&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;setFirstNumber(int&nbsp;firstNumber);&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;setSecondNumber(int&nbsp;secondNumber);} /**&nbsp;*&nbsp;Originator&nbsp;Implementation&nbsp;*/public&nbsp;class&nbsp;CalculatorImp&nbsp;implements&nbsp;Calculator&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;firstNumber;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;secondNumber;&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;PreviousCalculationToCareTaker&nbsp;backupLastCalculation()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;create&nbsp;a&nbsp;memento&nbsp;object&nbsp;used&nbsp;for&nbsp;restoring&nbsp;two&nbsp;numbers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;PreviousCalculationImp(firstNumber,&nbsp;secondNumber);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;restorePreviousCalculation(PreviousCalculationToCareTaker&nbsp;memento)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.firstNumber&nbsp;=&nbsp;((PreviousCalculationToOriginator)&nbsp;memento).getFirstNumber();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.secondNumber&nbsp;=&nbsp;((PreviousCalculationToOriginator)&nbsp;memento).getSecondNumber();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;getCalculationResult()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;result&nbsp;is&nbsp;adding&nbsp;two&nbsp;numbers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;firstNumber&nbsp;+&nbsp;secondNumber;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setFirstNumber(int&nbsp;firstNumber)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.firstNumber&nbsp;=&nbsp;firstNumber;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setSecondNumber(int&nbsp;secondNumber)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.secondNumber&nbsp;=&nbsp;secondNumber;&nbsp;&nbsp;&nbsp;&nbsp;}} /**&nbsp;*&nbsp;Memento&nbsp;Interface&nbsp;to&nbsp;Originator&nbsp;*&nbsp;*&nbsp;This&nbsp;interface&nbsp;allows&nbsp;the&nbsp;originator&nbsp;to&nbsp;restore&nbsp;its&nbsp;state&nbsp;*/public&nbsp;interface&nbsp;PreviousCalculationToOriginator&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;getFirstNumber();&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;getSecondNumber();} /**&nbsp;*&nbsp;&nbsp;Memento&nbsp;interface&nbsp;to&nbsp;CalculatorOperator&nbsp;(Caretaker)&nbsp;*/public&nbsp;interface&nbsp;PreviousCalculationToCareTaker&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;no&nbsp;operations&nbsp;permitted&nbsp;for&nbsp;the&nbsp;caretaker} /**&nbsp;*&nbsp;Memento&nbsp;Object&nbsp;Implementation&nbsp;*&nbsp;&lt;p&gt;&nbsp;*&nbsp;Note&nbsp;that&nbsp;this&nbsp;object&nbsp;implements&nbsp;both&nbsp;interfaces&nbsp;to&nbsp;Originator&nbsp;and&nbsp;CareTaker&nbsp;*/public&nbsp;class&nbsp;PreviousCalculationImp&nbsp;implements&nbsp;PreviousCalculationToCareTaker,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PreviousCalculationToOriginator&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;firstNumber;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;secondNumber;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;PreviousCalculationImp(int&nbsp;firstNumber,&nbsp;int&nbsp;secondNumber)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.firstNumber&nbsp;=&nbsp;firstNumber;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.secondNumber&nbsp;=&nbsp;secondNumber;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;getFirstNumber()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;firstNumber;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;getSecondNumber()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;secondNumber;&nbsp;&nbsp;&nbsp;&nbsp;}} /**&nbsp;*&nbsp;CareTaker&nbsp;object&nbsp;*/public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;program&nbsp;starts&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculator&nbsp;calculator&nbsp;=&nbsp;new&nbsp;CalculatorImp();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;assume&nbsp;user&nbsp;enters&nbsp;two&nbsp;numbers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calculator.setFirstNumber(10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calculator.setSecondNumber(100);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;find&nbsp;result&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(calculator.getCalculationResult());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Store&nbsp;result&nbsp;of&nbsp;this&nbsp;calculation&nbsp;in&nbsp;case&nbsp;of&nbsp;error&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PreviousCalculationToCareTaker&nbsp;memento&nbsp;=&nbsp;calculator.backupLastCalculation();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;user&nbsp;enters&nbsp;a&nbsp;number&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calculator.setFirstNumber(17);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;user&nbsp;enters&nbsp;a&nbsp;wrong&nbsp;second&nbsp;number&nbsp;and&nbsp;calculates&nbsp;result&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calculator.setSecondNumber(-290);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;calculate&nbsp;result&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(calculator.getCalculationResult());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;user&nbsp;hits&nbsp;CTRL&nbsp;+&nbsp;Z&nbsp;to&nbsp;undo&nbsp;last&nbsp;operation&nbsp;and&nbsp;see&nbsp;last&nbsp;result&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calculator.restorePreviousCalculation(memento);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;result&nbsp;restored&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(calculator.getCalculationResult());&nbsp;&nbsp;&nbsp;&nbsp;}} 110-273110 JDK java.io.Serializable 7. 观察者（Observer） Intent 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。 主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。 img Class Diagram 主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。 观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。 img Implementation 天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。 img public&nbsp;interface&nbsp;Subject&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;registerObserver(Observer&nbsp;o);&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;removeObserver(Observer&nbsp;o);&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;notifyObserver();} public&nbsp;class&nbsp;WeatherData&nbsp;implements&nbsp;Subject&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;List&lt;Observer&gt;&nbsp;observers;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;float&nbsp;temperature;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;float&nbsp;humidity;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;float&nbsp;pressure;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;WeatherData()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observers&nbsp;=&nbsp;new&nbsp;ArrayList&lt;&gt;();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setMeasurements(float&nbsp;temperature,&nbsp;float&nbsp;humidity,&nbsp;float&nbsp;pressure)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.temperature&nbsp;=&nbsp;temperature;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.humidity&nbsp;=&nbsp;humidity;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.pressure&nbsp;=&nbsp;pressure;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;notifyObserver();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;registerObserver(Observer&nbsp;o)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observers.add(o);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;removeObserver(Observer&nbsp;o)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;i&nbsp;=&nbsp;observers.indexOf(o);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(i&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;observers.remove(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;notifyObserver()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Observer&nbsp;o&nbsp;:&nbsp;observers)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;o.update(temperature,&nbsp;humidity,&nbsp;pressure);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;interface&nbsp;Observer&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;update(float&nbsp;temp,&nbsp;float&nbsp;humidity,&nbsp;float&nbsp;pressure);} public&nbsp;class&nbsp;StatisticsDisplay&nbsp;implements&nbsp;Observer&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;StatisticsDisplay(Subject&nbsp;weatherData)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weatherData.reisterObserver(this);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;update(float&nbsp;temp,&nbsp;float&nbsp;humidity,&nbsp;float&nbsp;pressure)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("StatisticsDisplay.update:&nbsp;"&nbsp;+&nbsp;temp&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;humidity&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;pressure);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;CurrentConditionsDisplay&nbsp;implements&nbsp;Observer&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;CurrentConditionsDisplay(Subject&nbsp;weatherData)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weatherData.registerObserver(this);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;update(float&nbsp;temp,&nbsp;float&nbsp;humidity,&nbsp;float&nbsp;pressure)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("CurrentConditionsDisplay.update:&nbsp;"&nbsp;+&nbsp;temp&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;humidity&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;pressure);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;WeatherStation&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WeatherData&nbsp;weatherData&nbsp;=&nbsp;new&nbsp;WeatherData();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CurrentConditionsDisplay&nbsp;currentConditionsDisplay&nbsp;=&nbsp;new&nbsp;CurrentConditionsDisplay(weatherData);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StatisticsDisplay&nbsp;statisticsDisplay&nbsp;=&nbsp;new&nbsp;StatisticsDisplay(weatherData);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weatherData.setMeasurements(0,&nbsp;0,&nbsp;0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weatherData.setMeasurements(1,&nbsp;1,&nbsp;1);&nbsp;&nbsp;&nbsp;&nbsp;}} CurrentConditionsDisplay.update:&nbsp;0.0&nbsp;0.0&nbsp;0.0StatisticsDisplay.update:&nbsp;0.0&nbsp;0.0&nbsp;0.0CurrentConditionsDisplay.update:&nbsp;1.0&nbsp;1.0&nbsp;1.0StatisticsDisplay.update:&nbsp;1.0&nbsp;1.0&nbsp;1.0 JDK java.util.Observer java.util.EventListener javax.servlet.http.HttpSessionBindingListener RxJava 8. 状态（State） Intent 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。 Class Diagram img Implementation 糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。 img public&nbsp;interface&nbsp;State&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;投入&nbsp;25&nbsp;分钱&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;insertQuarter();&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;退回&nbsp;25&nbsp;分钱&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;ejectQuarter();&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;转动曲柄&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;turnCrank();&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;发放糖果&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;dispense();} public&nbsp;class&nbsp;HasQuarterState&nbsp;implements&nbsp;State&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;GumballMachine&nbsp;gumballMachine;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;HasQuarterState(GumballMachine&nbsp;gumballMachine)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.gumballMachine&nbsp;=&nbsp;gumballMachine;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insertQuarter()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("You&nbsp;can't&nbsp;insert&nbsp;another&nbsp;quarter");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;ejectQuarter()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Quarter&nbsp;returned");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.setState(gumballMachine.getNoQuarterState());&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;turnCrank()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("You&nbsp;turned...");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.setState(gumballMachine.getSoldState());&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;dispense()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("No&nbsp;gumball&nbsp;dispensed");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;NoQuarterState&nbsp;implements&nbsp;State&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;GumballMachine&nbsp;gumballMachine;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;NoQuarterState(GumballMachine&nbsp;gumballMachine)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.gumballMachine&nbsp;=&nbsp;gumballMachine;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insertQuarter()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("You&nbsp;insert&nbsp;a&nbsp;quarter");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.setState(gumballMachine.getHasQuarterState());&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;ejectQuarter()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("You&nbsp;haven't&nbsp;insert&nbsp;a&nbsp;quarter");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;turnCrank()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("You&nbsp;turned,&nbsp;but&nbsp;there's&nbsp;no&nbsp;quarter");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;dispense()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("You&nbsp;need&nbsp;to&nbsp;pay&nbsp;first");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;SoldOutState&nbsp;implements&nbsp;State&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;GumballMachine&nbsp;gumballMachine;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;SoldOutState(GumballMachine&nbsp;gumballMachine)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.gumballMachine&nbsp;=&nbsp;gumballMachine;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insertQuarter()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("You&nbsp;can't&nbsp;insert&nbsp;a&nbsp;quarter,&nbsp;the&nbsp;machine&nbsp;is&nbsp;sold&nbsp;out");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;ejectQuarter()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("You&nbsp;can't&nbsp;eject,&nbsp;you&nbsp;haven't&nbsp;inserted&nbsp;a&nbsp;quarter&nbsp;yet");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;turnCrank()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("You&nbsp;turned,&nbsp;but&nbsp;there&nbsp;are&nbsp;no&nbsp;gumballs");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;dispense()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("No&nbsp;gumball&nbsp;dispensed");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;SoldState&nbsp;implements&nbsp;State&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;GumballMachine&nbsp;gumballMachine;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;SoldState(GumballMachine&nbsp;gumballMachine)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.gumballMachine&nbsp;=&nbsp;gumballMachine;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insertQuarter()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Please&nbsp;wait,&nbsp;we're&nbsp;already&nbsp;giving&nbsp;you&nbsp;a&nbsp;gumball");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;ejectQuarter()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Sorry,&nbsp;you&nbsp;already&nbsp;turned&nbsp;the&nbsp;crank");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;turnCrank()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Turning&nbsp;twice&nbsp;doesn't&nbsp;get&nbsp;you&nbsp;another&nbsp;gumball!");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;dispense()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.releaseBall();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(gumballMachine.getCount()&nbsp;&gt;&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.setState(gumballMachine.getNoQuarterState());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Oops,&nbsp;out&nbsp;of&nbsp;gumballs");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.setState(gumballMachine.getSoldOutState());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;GumballMachine&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;State&nbsp;soldOutState;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;State&nbsp;noQuarterState;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;State&nbsp;hasQuarterState;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;State&nbsp;soldState;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;State&nbsp;state;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;count&nbsp;=&nbsp;0;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;GumballMachine(int&nbsp;numberGumballs)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;=&nbsp;numberGumballs;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soldOutState&nbsp;=&nbsp;new&nbsp;SoldOutState(this);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;noQuarterState&nbsp;=&nbsp;new&nbsp;NoQuarterState(this);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasQuarterState&nbsp;=&nbsp;new&nbsp;HasQuarterState(this);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soldState&nbsp;=&nbsp;new&nbsp;SoldState(this);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(numberGumballs&nbsp;&gt;&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state&nbsp;=&nbsp;noQuarterState;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state&nbsp;=&nbsp;soldOutState;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insertQuarter()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state.insertQuarter();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;ejectQuarter()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state.ejectQuarter();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;turnCrank()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state.turnCrank();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state.dispense();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setState(State&nbsp;state)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.state&nbsp;=&nbsp;state;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;releaseBall()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("A&nbsp;gumball&nbsp;comes&nbsp;rolling&nbsp;out&nbsp;the&nbsp;slot...");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(count&nbsp;!=&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;count&nbsp;-=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;State&nbsp;getSoldOutState()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;soldOutState;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;State&nbsp;getNoQuarterState()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;noQuarterState;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;State&nbsp;getHasQuarterState()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;hasQuarterState;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;State&nbsp;getSoldState()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;soldState;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;getCount()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;count;&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GumballMachine&nbsp;gumballMachine&nbsp;=&nbsp;new&nbsp;GumballMachine(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.insertQuarter();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.turnCrank();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.insertQuarter();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.ejectQuarter();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.turnCrank();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.insertQuarter();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.turnCrank();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.insertQuarter();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.turnCrank();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.ejectQuarter();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.insertQuarter();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.insertQuarter();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.turnCrank();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.insertQuarter();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.turnCrank();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.insertQuarter();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gumballMachine.turnCrank();&nbsp;&nbsp;&nbsp;&nbsp;}} You&nbsp;insert&nbsp;a&nbsp;quarterYou&nbsp;turned...A&nbsp;gumball&nbsp;comes&nbsp;rolling&nbsp;out&nbsp;the&nbsp;slot...You&nbsp;insert&nbsp;a&nbsp;quarterQuarter&nbsp;returnedYou&nbsp;turned,&nbsp;but&nbsp;there's&nbsp;no&nbsp;quarterYou&nbsp;need&nbsp;to&nbsp;pay&nbsp;firstYou&nbsp;insert&nbsp;a&nbsp;quarterYou&nbsp;turned...A&nbsp;gumball&nbsp;comes&nbsp;rolling&nbsp;out&nbsp;the&nbsp;slot...You&nbsp;insert&nbsp;a&nbsp;quarterYou&nbsp;turned...A&nbsp;gumball&nbsp;comes&nbsp;rolling&nbsp;out&nbsp;the&nbsp;slot...You&nbsp;haven't&nbsp;insert&nbsp;a&nbsp;quarterYou&nbsp;insert&nbsp;a&nbsp;quarterYou&nbsp;can't&nbsp;insert&nbsp;another&nbsp;quarterYou&nbsp;turned...A&nbsp;gumball&nbsp;comes&nbsp;rolling&nbsp;out&nbsp;the&nbsp;slot...You&nbsp;insert&nbsp;a&nbsp;quarterYou&nbsp;turned...A&nbsp;gumball&nbsp;comes&nbsp;rolling&nbsp;out&nbsp;the&nbsp;slot...Oops,&nbsp;out&nbsp;of&nbsp;gumballsYou&nbsp;can't&nbsp;insert&nbsp;a&nbsp;quarter,&nbsp;the&nbsp;machine&nbsp;is&nbsp;sold&nbsp;outYou&nbsp;turned,&nbsp;but&nbsp;there&nbsp;are&nbsp;no&nbsp;gumballsNo&nbsp;gumball&nbsp;dispensed 9. 策略（Strategy） Intent 定义一系列算法，封装每个算法，并使它们可以互换。 策略模式可以让算法独立于使用它的客户端。 Class Diagram Strategy 接口定义了一个算法族，它们都实现了 behavior() 方法。 Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。 img 与状态模式的比较 状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。 状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。 Implementation 设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。 public&nbsp;interface&nbsp;QuackBehavior&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;quack();} public&nbsp;class&nbsp;Quack&nbsp;implements&nbsp;QuackBehavior&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;quack()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("quack!");&nbsp;&nbsp;&nbsp;&nbsp;}} javapublic class Squeak implements QuackBehavior{ @Override public void quack() { System.out.println("squeak!"); }} ```javapublic&nbsp;class&nbsp;Duck&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;QuackBehavior&nbsp;quackBehavior;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;performQuack()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(quackBehavior&nbsp;!=&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quackBehavior.quack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setQuackBehavior(QuackBehavior&nbsp;quackBehavior)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.quackBehavior&nbsp;=&nbsp;quackBehavior;&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Duck&nbsp;duck&nbsp;=&nbsp;new&nbsp;Duck();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duck.setQuackBehavior(new&nbsp;Squeak());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duck.performQuack();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duck.setQuackBehavior(new&nbsp;Quack());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duck.performQuack();&nbsp;&nbsp;&nbsp;&nbsp;}} squeak!quack! JDK java.util.Comparator#compare() javax.servlet.http.HttpServlet javax.servlet.Filter#doFilter() 10. 模板方法（Template Method） Intent 定义算法框架，并将一些步骤的实现延迟到子类。 通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。 Class Diagram img Implementation 冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。 img public&nbsp;abstract&nbsp;class&nbsp;CaffeineBeverage&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;final&nbsp;void&nbsp;prepareRecipe()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boilWater();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;brew();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pourInCup();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addCondiments();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;void&nbsp;brew();&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;void&nbsp;addCondiments();&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;boilWater()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("boilWater");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;pourInCup()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("pourInCup");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Coffee&nbsp;extends&nbsp;CaffeineBeverage&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;brew()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Coffee.brew");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;addCondiments()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Coffee.addCondiments");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Tea&nbsp;extends&nbsp;CaffeineBeverage&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;brew()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Tea.brew");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;addCondiments()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Tea.addCondiments");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CaffeineBeverage&nbsp;caffeineBeverage&nbsp;=&nbsp;new&nbsp;Coffee();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;caffeineBeverage.prepareRecipe();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("-----------");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;caffeineBeverage&nbsp;=&nbsp;new&nbsp;Tea();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;caffeineBeverage.prepareRecipe();&nbsp;&nbsp;&nbsp;&nbsp;}} boilWaterCoffee.brewpourInCupCoffee.addCondiments-----------boilWaterTea.brewpourInCupTea.addCondiments JDK java.util.Collections#sort() java.io.InputStream#skip() java.io.InputStream#read() java.util.AbstractList#indexOf() 11. 访问者（Visitor） Intent 为一个对象结构（比如组合结构）增加新能力。 Class Diagram Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作 ConcreteVisitor：具体访问者，存储遍历过程中的累计结果 ObjectStructure：对象结构，可以是组合结构，或者是一个集合。 img Implementation public&nbsp;interface&nbsp;Element&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;accept(Visitor&nbsp;visitor);} class&nbsp;CustomerGroup&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;List&lt;Customer&gt;&nbsp;customers&nbsp;=&nbsp;new&nbsp;ArrayList&lt;&gt;();&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;accept(Visitor&nbsp;visitor)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Customer&nbsp;customer&nbsp;:&nbsp;customers)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customer.accept(visitor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;addCustomer(Customer&nbsp;customer)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customers.add(customer);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Customer&nbsp;implements&nbsp;Element&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;List&lt;Order&gt;&nbsp;orders&nbsp;=&nbsp;new&nbsp;ArrayList&lt;&gt;();&nbsp;&nbsp;&nbsp;&nbsp;Customer(String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;getName()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;addOrder(Order&nbsp;order)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;orders.add(order);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;accept(Visitor&nbsp;visitor)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitor.visit(this);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Order&nbsp;order&nbsp;:&nbsp;orders)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order.accept(visitor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Order&nbsp;implements&nbsp;Element&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;List&lt;Item&gt;&nbsp;items&nbsp;=&nbsp;new&nbsp;ArrayList();&nbsp;&nbsp;&nbsp;&nbsp;Order(String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;Order(String&nbsp;name,&nbsp;String&nbsp;itemName)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.addItem(new&nbsp;Item(itemName));&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;getName()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;addItem(Item&nbsp;item)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;items.add(item);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;accept(Visitor&nbsp;visitor)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitor.visit(this);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Item&nbsp;item&nbsp;:&nbsp;items)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;item.accept(visitor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Item&nbsp;implements&nbsp;Element&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;Item(String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;getName()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;accept(Visitor&nbsp;visitor)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitor.visit(this);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;interface&nbsp;Visitor&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;visit(Customer&nbsp;customer);&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;visit(Order&nbsp;order);&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;visit(Item&nbsp;item);} public&nbsp;class&nbsp;GeneralReport&nbsp;implements&nbsp;Visitor&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;customersNo;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;ordersNo;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;itemsNo;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;visit(Customer&nbsp;customer)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(customer.getName());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customersNo++;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;visit(Order&nbsp;order)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(order.getName());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ordersNo++;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;visit(Item&nbsp;item)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(item.getName());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itemsNo++;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;displayResults()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Number&nbsp;of&nbsp;customers:&nbsp;"&nbsp;+&nbsp;customersNo);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Number&nbsp;of&nbsp;orders:&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;+&nbsp;ordersNo);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Number&nbsp;of&nbsp;items:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;+&nbsp;itemsNo);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Customer&nbsp;customer1&nbsp;=&nbsp;new&nbsp;Customer("customer1");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customer1.addOrder(new&nbsp;Order("order1",&nbsp;"item1"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customer1.addOrder(new&nbsp;Order("order2",&nbsp;"item1"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customer1.addOrder(new&nbsp;Order("order3",&nbsp;"item1"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Order&nbsp;order&nbsp;=&nbsp;new&nbsp;Order("order_a");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order.addItem(new&nbsp;Item("item_a1"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order.addItem(new&nbsp;Item("item_a2"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;order.addItem(new&nbsp;Item("item_a3"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Customer&nbsp;customer2&nbsp;=&nbsp;new&nbsp;Customer("customer2");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customer2.addOrder(order);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CustomerGroup&nbsp;customers&nbsp;=&nbsp;new&nbsp;CustomerGroup();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customers.addCustomer(customer1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customers.addCustomer(customer2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GeneralReport&nbsp;visitor&nbsp;=&nbsp;new&nbsp;GeneralReport();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;customers.accept(visitor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visitor.displayResults();&nbsp;&nbsp;&nbsp;&nbsp;}} customer1order1item1order2item1order3item1customer2order_aitem_a1item_a2item_a3Number&nbsp;of&nbsp;customers:&nbsp;2Number&nbsp;of&nbsp;orders:&nbsp;&nbsp;&nbsp;&nbsp;4Number&nbsp;of&nbsp;items:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6 JDK javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor 12. 空对象（Null） Intent 使用什么都不做的空对象来代替 NULL。 一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。 Class Diagram img Implementation public&nbsp;abstract&nbsp;class&nbsp;AbstractOperation&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;void&nbsp;request();} public&nbsp;class&nbsp;RealOperation&nbsp;extends&nbsp;AbstractOperation&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;request()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("do&nbsp;something");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;NullOperation&nbsp;extends&nbsp;AbstractOperation{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;request()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;do&nbsp;nothing&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AbstractOperation&nbsp;abstractOperation&nbsp;=&nbsp;func(-1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstractOperation.request();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;AbstractOperation&nbsp;func(int&nbsp;para)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(para&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;NullOperation();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;new&nbsp;RealOperation();&nbsp;&nbsp;&nbsp;&nbsp;}} 四、结构型 1. 适配器（Adapter） Intent 把一个类接口转换成另一个用户需要的接口。 img Class Diagram img Implementation 鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。 要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！ public&nbsp;interface&nbsp;Duck&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;quack();} public&nbsp;interface&nbsp;Turkey&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;gobble();} public&nbsp;class&nbsp;WildTurkey&nbsp;implements&nbsp;Turkey&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;gobble()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("gobble!");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;TurkeyAdapter&nbsp;implements&nbsp;Duck&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;Turkey&nbsp;turkey;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;TurkeyAdapter(Turkey&nbsp;turkey)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.turkey&nbsp;=&nbsp;turkey;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;quack()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turkey.gobble();&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turkey&nbsp;turkey&nbsp;=&nbsp;new&nbsp;WildTurkey();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Duck&nbsp;duck&nbsp;=&nbsp;new&nbsp;TurkeyAdapter(turkey);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;duck.quack();&nbsp;&nbsp;&nbsp;&nbsp;}} JDK java.util.Arrays#asList() java.util.Collections#list() java.util.Collections#enumeration() javax.xml.bind.annotation.adapters.XMLAdapter 2. 桥接（Bridge） Intent 将抽象与实现分离开来，使它们可以独立变化。 Class Diagram Abstraction：定义抽象类的接口 Implementor：定义实现类接口 img Implementation RemoteControl 表示遥控器，指代 Abstraction。 TV 表示电视，指代 Implementor。 桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。 public&nbsp;abstract&nbsp;class&nbsp;TV&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;void&nbsp;on();&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;void&nbsp;off();&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;void&nbsp;tuneChannel();} public&nbsp;class&nbsp;Sony&nbsp;extends&nbsp;TV&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;on()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Sony.on()");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;off()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Sony.off()");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;tuneChannel()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Sony.tuneChannel()");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;RCA&nbsp;extends&nbsp;TV&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;on()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("RCA.on()");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;off()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("RCA.off()");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;tuneChannel()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("RCA.tuneChannel()");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;abstract&nbsp;class&nbsp;RemoteControl&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;TV&nbsp;tv;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;RemoteControl(TV&nbsp;tv)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.tv&nbsp;=&nbsp;tv;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;void&nbsp;on();&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;void&nbsp;off();&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;void&nbsp;tuneChannel();} public&nbsp;class&nbsp;ConcreteRemoteControl1&nbsp;extends&nbsp;RemoteControl&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ConcreteRemoteControl1(TV&nbsp;tv)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(tv);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;on()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("ConcreteRemoteControl1.on()");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tv.on();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;off()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("ConcreteRemoteControl1.off()");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tv.off();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;tuneChannel()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("ConcreteRemoteControl1.tuneChannel()");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tv.tuneChannel();&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;ConcreteRemoteControl2&nbsp;extends&nbsp;RemoteControl&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ConcreteRemoteControl2(TV&nbsp;tv)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(tv);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;on()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("ConcreteRemoteControl2.on()");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tv.on();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;off()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("ConcreteRemoteControl2.off()");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tv.off();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;tuneChannel()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("ConcreteRemoteControl2.tuneChannel()");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tv.tuneChannel();&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RemoteControl&nbsp;remoteControl1&nbsp;=&nbsp;new&nbsp;ConcreteRemoteControl1(new&nbsp;RCA());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remoteControl1.on();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remoteControl1.off();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remoteControl1.tuneChannel();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RemoteControl&nbsp;remoteControl2&nbsp;=&nbsp;new&nbsp;ConcreteRemoteControl2(new&nbsp;Sony());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remoteControl2.on();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remoteControl2.off();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remoteControl2.tuneChannel();&nbsp;&nbsp;&nbsp;&nbsp;}} JDK AWT (It provides an abstraction layer which maps onto the native OS the windowing support.) JDBC 3. 组合（Composite） Intent 将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。 Class Diagram 组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。 组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。 img Implementation public&nbsp;abstract&nbsp;class&nbsp;Component&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;String&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Component(String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;print()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(0);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;void&nbsp;print(int&nbsp;level);&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;public&nbsp;void&nbsp;add(Component&nbsp;component);&nbsp;&nbsp;&nbsp;&nbsp;abstract&nbsp;public&nbsp;void&nbsp;remove(Component&nbsp;component);} public&nbsp;class&nbsp;Composite&nbsp;extends&nbsp;Component&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;List&lt;Component&gt;&nbsp;child;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Composite(String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child&nbsp;=&nbsp;new&nbsp;ArrayList&lt;&gt;();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print(int&nbsp;level)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;level;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print("--");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Composite:"&nbsp;+&nbsp;name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(Component&nbsp;component&nbsp;:&nbsp;child)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;component.print(level&nbsp;+&nbsp;1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;add(Component&nbsp;component)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child.add(component);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;remove(Component&nbsp;component)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child.remove(component);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Leaf&nbsp;extends&nbsp;Component&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Leaf(String&nbsp;name)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(name);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;print(int&nbsp;level)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;level;&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.print("--");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("left:"&nbsp;+&nbsp;name);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;add(Component&nbsp;component)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;UnsupportedOperationException();&nbsp;//&nbsp;牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;remove(Component&nbsp;component)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;UnsupportedOperationException();&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Composite&nbsp;root&nbsp;=&nbsp;new&nbsp;Composite("root");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component&nbsp;node1&nbsp;=&nbsp;new&nbsp;Leaf("1");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component&nbsp;node2&nbsp;=&nbsp;new&nbsp;Composite("2");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component&nbsp;node3&nbsp;=&nbsp;new&nbsp;Leaf("3");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root.add(node1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root.add(node2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root.add(node3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component&nbsp;node21&nbsp;=&nbsp;new&nbsp;Leaf("21");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component&nbsp;node22&nbsp;=&nbsp;new&nbsp;Composite("22");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node2.add(node21);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node2.add(node22);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component&nbsp;node221&nbsp;=&nbsp;new&nbsp;Leaf("221");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node22.add(node221);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root.print();&nbsp;&nbsp;&nbsp;&nbsp;}} Composite:root--left:1--Composite:2----left:21----Composite:22------left:221--left:3 JDK javax.swing.JComponent#add(Component) java.awt.Container#add(Component) java.util.Map#putAll(Map) java.util.List#addAll(Collection) java.util.Set#addAll(Collection) 4. 装饰（Decorator） Intent 为对象动态添加功能。 Class Diagram 装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。 img Implementation 设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。 下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。 img public&nbsp;interface&nbsp;Beverage&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;cost();} public&nbsp;class&nbsp;DarkRoast&nbsp;implements&nbsp;Beverage&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;double&nbsp;cost()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;HouseBlend&nbsp;implements&nbsp;Beverage&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;double&nbsp;cost()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;abstract&nbsp;class&nbsp;CondimentDecorator&nbsp;implements&nbsp;Beverage&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;Beverage&nbsp;beverage;} public&nbsp;class&nbsp;Milk&nbsp;extends&nbsp;CondimentDecorator&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Milk(Beverage&nbsp;beverage)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.beverage&nbsp;=&nbsp;beverage;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;double&nbsp;cost()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1&nbsp;+&nbsp;beverage.cost();&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Mocha&nbsp;extends&nbsp;CondimentDecorator&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;Mocha(Beverage&nbsp;beverage)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.beverage&nbsp;=&nbsp;beverage;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;double&nbsp;cost()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;1&nbsp;+&nbsp;beverage.cost();&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Beverage&nbsp;beverage&nbsp;=&nbsp;new&nbsp;HouseBlend();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beverage&nbsp;=&nbsp;new&nbsp;Mocha(beverage);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beverage&nbsp;=&nbsp;new&nbsp;Milk(beverage);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(beverage.cost());&nbsp;&nbsp;&nbsp;&nbsp;}} 设计原则 类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。 不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。 JDK java.io.BufferedInputStream(InputStream) java.io.DataInputStream(InputStream) java.io.BufferedOutputStream(OutputStream) java.util.zip.ZipOutputStream(OutputStream) java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap 5. 外观（Facade） Intent 提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。 Class Diagram img Implementation 观看电影需要操作很多电器，使用外观模式实现一键看电影功能。 public&nbsp;class&nbsp;SubSystem&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;turnOnTV()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("turnOnTV()");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setCD(String&nbsp;cd)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("setCD(&nbsp;"&nbsp;+&nbsp;cd&nbsp;+&nbsp;"&nbsp;)");&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;startWatching(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("startWatching()");&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Facade&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;SubSystem&nbsp;subSystem&nbsp;=&nbsp;new&nbsp;SubSystem();&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;watchMovie()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subSystem.turnOnTV();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subSystem.setCD("a&nbsp;movie");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;subSystem.startWatching();&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Facade&nbsp;facade&nbsp;=&nbsp;new&nbsp;Facade();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;facade.watchMovie();&nbsp;&nbsp;&nbsp;&nbsp;}} 设计原则 最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。 6. 享元（Flyweight） Intent 利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。 Class Diagram Flyweight：享元对象 IntrinsicState：内部状态，享元对象共享内部状态 ExtrinsicState：外部状态，每个享元对象的外部状态不同 img Implementation public&nbsp;interface&nbsp;Flyweight&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;doOperation(String&nbsp;extrinsicState);} public&nbsp;class&nbsp;ConcreteFlyweight&nbsp;implements&nbsp;Flyweight&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;String&nbsp;intrinsicState;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ConcreteFlyweight(String&nbsp;intrinsicState)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.intrinsicState&nbsp;=&nbsp;intrinsicState;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doOperation(String&nbsp;extrinsicState)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Object&nbsp;address:&nbsp;"&nbsp;+&nbsp;System.identityHashCode(this));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("IntrinsicState:&nbsp;"&nbsp;+&nbsp;intrinsicState);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("ExtrinsicState:&nbsp;"&nbsp;+&nbsp;extrinsicState);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;FlyweightFactory&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;HashMap&lt;String,&nbsp;Flyweight&gt;&nbsp;flyweights&nbsp;=&nbsp;new&nbsp;HashMap&lt;&gt;();&nbsp;&nbsp;&nbsp;&nbsp;Flyweight&nbsp;getFlyweight(String&nbsp;intrinsicState)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!flyweights.containsKey(intrinsicState))&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flyweight&nbsp;flyweight&nbsp;=&nbsp;new&nbsp;ConcreteFlyweight(intrinsicState);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flyweights.put(intrinsicState,&nbsp;flyweight);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;flyweights.get(intrinsicState);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;Client&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FlyweightFactory&nbsp;factory&nbsp;=&nbsp;new&nbsp;FlyweightFactory();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flyweight&nbsp;flyweight1&nbsp;=&nbsp;factory.getFlyweight("aa");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Flyweight&nbsp;flyweight2&nbsp;=&nbsp;factory.getFlyweight("aa");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flyweight1.doOperation("x");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;flyweight2.doOperation("y");&nbsp;&nbsp;&nbsp;&nbsp;}} Object&nbsp;address:&nbsp;1163157884IntrinsicState:&nbsp;aaExtrinsicState:&nbsp;xObject&nbsp;address:&nbsp;1163157884IntrinsicState:&nbsp;aaExtrinsicState:&nbsp;y JDK Java 利用缓存来加速大量小对象的访问时间。 java.lang.Integer#valueOf(int) java.lang.Boolean#valueOf(boolean) java.lang.Byte#valueOf(byte) java.lang.Character#valueOf(char) 7. 代理（Proxy） Intent 控制对其它对象的访问。 Class Diagram 代理有以下四类： 远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。 虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。 保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。 智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。 img Implementation 以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。 public&nbsp;interface&nbsp;Image&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;showImage();} public&nbsp;class&nbsp;HighResolutionImage&nbsp;implements&nbsp;Image&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;URL&nbsp;imageURL;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;startTime;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;height;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;int&nbsp;width;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;getHeight()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;height;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;int&nbsp;getWidth()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;width;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;HighResolutionImage(URL&nbsp;imageURL)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.imageURL&nbsp;=&nbsp;imageURL;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.startTime&nbsp;=&nbsp;System.currentTimeMillis();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width&nbsp;=&nbsp;600;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.height&nbsp;=&nbsp;600;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;boolean&nbsp;isLoad()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;模拟图片加载，延迟&nbsp;3s&nbsp;加载完成&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;endTime&nbsp;=&nbsp;System.currentTimeMillis();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;endTime&nbsp;-&nbsp;startTime&nbsp;&gt;&nbsp;3000;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;showImage()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Real&nbsp;Image:&nbsp;"&nbsp;+&nbsp;imageURL);&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;ImageProxy&nbsp;implements&nbsp;Image&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;HighResolutionImage&nbsp;highResolutionImage;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;ImageProxy(HighResolutionImage&nbsp;highResolutionImage)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.highResolutionImage&nbsp;=&nbsp;highResolutionImage;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;showImage()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(!highResolutionImage.isLoad())&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Temp&nbsp;Image:&nbsp;"&nbsp;+&nbsp;highResolutionImage.getWidth()&nbsp;+&nbsp;"&nbsp;"&nbsp;+&nbsp;highResolutionImage.getHeight());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread.sleep(100);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InterruptedException&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;highResolutionImage.showImage();&nbsp;&nbsp;&nbsp;&nbsp;}} public&nbsp;class&nbsp;ImageViewer&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;throws&nbsp;Exception&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;image&nbsp;=&nbsp;"http://image.jpg";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;URL&nbsp;url&nbsp;=&nbsp;new&nbsp;URL(image);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HighResolutionImage&nbsp;highResolutionImage&nbsp;=&nbsp;new&nbsp;HighResolutionImage(url);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ImageProxy&nbsp;imageProxy&nbsp;=&nbsp;new&nbsp;ImageProxy(highResolutionImage);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;imageProxy.showImage();&nbsp;&nbsp;&nbsp;&nbsp;}} JDK java.lang.reflect.Proxy RMI 参考资料 弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007. Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007. Bloch J. Effective java[M]. Addison-Wesley Professional, 2017. Design Patterns Design patterns implemented in Java [The breakdown of design patterns in JDK]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式ID生成方式总结]]></title>
    <url>%2F2020%2F02%2F06%2F8.%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、为什么要用分布式ID？ 在说分布式ID的具体实现之前，我们来简单分析一下为什么用分布式ID？分布式ID应该满足哪些特征？ 1、什么是分布式ID？ 拿MySQL数据库举个栗子： 在我们业务数据量不大的时候，单库单表完全可以支撑现有业务，数据再大一点搞个MySQL主从同步读写分离也能对付。 但随着数据日渐增长，主从同步也扛不住了，就需要对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据，数据库的自增ID显然不能满足需求；特别一点的如订单、优惠券也都需要有唯一ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。那么这个全局唯一ID就叫分布式ID。 2、那么分布式ID需要满足那些条件？ 全局唯一：必须保证ID是全局性唯一的，基本要求 高性能：高可用低延时，ID生成响应要块，否则反倒会成为业务瓶颈 高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性 好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单 趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求 二、 分布式ID都有哪些生成方式？ 今天主要分析一下以下9种，分布式ID生成器方式以及优缺点： UUID 数据库自增ID 数据库多主模式 号段模式 Redis 雪花算法（SnowFlake） 滴滴出品（TinyID） 百度 （Uidgenerator） 美团（Leaf） 那么它们都是如何实现？以及各自有什么优缺点？我们往下看 1、基于UUID 在Java的世界里，想要得到一个具有唯一性的ID，首先被想到可能就是UUID，毕竟它有着全球唯一的特性。那么UUID可以做分布式ID吗？答案是可以的，但是并不推荐！ public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;uuid&nbsp;=&nbsp;UUID.randomUUID().toString().replaceAll("-","");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(uuid);&nbsp;} UUID的生成简单到只有一行代码，输出结果 c2b8c2b9e46c47e3b30dca3b0d447718，但UUID却并不适用于实际的业务需求。像用作订单号UUID这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务主键ID，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作分布式ID。 优点： 生成足够简单，本地生成无网络消耗，具有唯一性 缺点： 无序的字符串，不具备趋势自增特性 没有具体的业务含义 长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 UUID 的无序性会导致数据位置频繁变动，严重影响性能。 2、基于数据库自增ID 基于数据库的auto_increment自增ID完全可以充当分布式ID，具体实现：需要一个单独的MySQL实例用来生成ID，建表结构如下： CREATE&nbsp;DATABASE&nbsp;`SEQ_ID`;CREATE&nbsp;TABLE&nbsp;SEQID.SEQUENCE_ID&nbsp;(&nbsp;&nbsp;&nbsp;&nbsp;id&nbsp;bigint(20)&nbsp;unsigned&nbsp;NOT&nbsp;NULL&nbsp;auto_increment,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value&nbsp;char(10)&nbsp;NOT&nbsp;NULL&nbsp;default&nbsp;'',&nbsp;&nbsp;&nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(id),)&nbsp;ENGINE=MyISAM;insert&nbsp;into&nbsp;SEQUENCE_ID(value)&nbsp;&nbsp;VALUES&nbsp;('values'); 当我们需要一个ID的时候，向表中插入一条记录返回主键ID，但这种方式有一个比较致命的缺点，访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！ 优点： 实现简单，ID单调自增，数值类型查询速度快 缺点： DB单点存在宕机风险，无法扛住高并发场景 3、基于数据库集群模式 前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个Mysql实例都能单独的生产自增ID。 那这样还会有个问题，两个MySQL实例的自增ID都从1开始，会生成重复的ID怎么办？ 解决方案：设置起始值和自增步长 MySQL_1 配置： set&nbsp;@@auto_increment_offset&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;起始值set&nbsp;@@auto_increment_increment&nbsp;=&nbsp;2;&nbsp;&nbsp;--&nbsp;步长 MySQL_2 配置： set&nbsp;@@auto_increment_offset&nbsp;=&nbsp;2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;起始值set&nbsp;@@auto_increment_increment&nbsp;=&nbsp;2;&nbsp;&nbsp;--&nbsp;步长 这样两个MySQL实例的自增ID分别就是： 1、3、5、7、9 2、4、6、8、10 那如果集群后的性能还是扛不住高并发咋办？就要进行MySQL扩容增加节点，这是一个比较麻烦的事。 在这里插入图片描述在这里插入图片描述 从上图可以看出，水平扩展的数据库集群，有利于解决数据库单点压力的问题，同时为了ID生成特性，将自增步长按照机器数量来设置。 增加第三台MySQL实例需要人工修改一、二两台MySQL实例的起始值和步长，把第三台机器的ID起始生成位置设定在比现有最大自增ID的位置远一些，但必须在一、二两台MySQL实例ID还没有增长到第三台MySQL实例的起始ID值的时候，否则自增ID就要出现重复了，必要时可能还需要停机修改。 优点： 解决DB单点问题 缺点： 不利于后续扩容，而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景。 4、基于数据库的号段模式 号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下： CREATE&nbsp;TABLE&nbsp;id_generator&nbsp;(&nbsp;&nbsp;id&nbsp;int(10)&nbsp;NOT&nbsp;NULL,&nbsp;&nbsp;max_id&nbsp;bigint(20)&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;'当前最大id',&nbsp;&nbsp;step&nbsp;int(20)&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;'号段的布长',&nbsp;&nbsp;biz_type&nbsp;&nbsp;&nbsp;&nbsp;int(20)&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;'业务类型',&nbsp;&nbsp;version&nbsp;int(20)&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;'版本号',&nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(`id`))&nbsp; biz_type ：代表不同业务类型 max_id ：当前最大的可用id step ：代表号段的长度 version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性 id biz_type max_id step version 1 101 1000 2000 0 等这批号段ID用完，再次向数据库申请新号段，对max_id字段做一次update操作，update max_id= max_id + step，update成功则说明新号段获取成功，新的号段范围是(max_id ,max_id +step]。 update&nbsp;id_generator&nbsp;set&nbsp;max_id&nbsp;=&nbsp;#{max_id+step},&nbsp;version&nbsp;=&nbsp;version&nbsp;+&nbsp;1&nbsp;where&nbsp;version&nbsp;=&nbsp;#&nbsp;{version}&nbsp;and&nbsp;biz_type&nbsp;=&nbsp;XXX 由于多业务端可能同时操作，所以采用版本号version乐观锁方式更新，这种分布式ID生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。 5、基于Redis模式 Redis也同样可以实现，原理就是利用redis的 incr命令实现ID的原子性自增。 127.0.0.1:6379&gt;&nbsp;set&nbsp;seq_id&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;初始化自增ID为1OK127.0.0.1:6379&gt;&nbsp;incr&nbsp;seq_id&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;增加1，并返回递增后的数值(integer)&nbsp;2 用redis实现需要注意一点，要考虑到redis持久化的问题。redis有两种持久化方式RDB和AOF RDB会定时打一个快照进行持久化，假如连续自增但redis没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。 AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致Redis重启恢复的数据时间过长。 6、基于雪花算法（Snowflake）模式 雪花算法（Snowflake）是twitter公司内部分布式项目采用的ID生成算法，开源后广受国内大厂的好评，在该算法影响下各大公司相继开发出各具特色的分布式生成器。 Snowflake生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。 Snowflake ID组成结构：正数位（占1比特）+ 时间戳（占41比特）+ 机器ID（占5比特）+ 数据中心（占5比特）+ 自增值（占12比特），总共64比特组成的一个Long类型。 第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。 时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年 工作机器id（10bit）：也被叫做workId，这个可以灵活配置，机房或者机器号组合都可以。 序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID 根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。 Java版本的Snowflake算法实现： /**&nbsp;*&nbsp;Twitter的SnowFlake算法,使用SnowFlake算法生成一个整数，然后转化为62进制变成一个短地址URL&nbsp;*&nbsp;*&nbsp;https://github.com/beyondfengyu/SnowFlake&nbsp;*/public&nbsp;class&nbsp;SnowFlakeShortUrl&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;起始的时间戳&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;static&nbsp;long&nbsp;START_TIMESTAMP&nbsp;=&nbsp;1480166465631L;&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;每一部分占用的位数&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;static&nbsp;long&nbsp;SEQUENCE_BIT&nbsp;=&nbsp;12;&nbsp;&nbsp;&nbsp;//序列号占用的位数&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;static&nbsp;long&nbsp;MACHINE_BIT&nbsp;=&nbsp;5;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//机器标识占用的位数&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;static&nbsp;long&nbsp;DATA_CENTER_BIT&nbsp;=&nbsp;5;&nbsp;//数据中心占用的位数&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;每一部分的最大值&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;static&nbsp;long&nbsp;MAX_SEQUENCE&nbsp;=&nbsp;-1L&nbsp;^&nbsp;(-1L&nbsp;&lt;&lt;&nbsp;SEQUENCE_BIT);&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;static&nbsp;long&nbsp;MAX_MACHINE_NUM&nbsp;=&nbsp;-1L&nbsp;^&nbsp;(-1L&nbsp;&lt;&lt;&nbsp;MACHINE_BIT);&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;static&nbsp;long&nbsp;MAX_DATA_CENTER_NUM&nbsp;=&nbsp;-1L&nbsp;^&nbsp;(-1L&nbsp;&lt;&lt;&nbsp;DATA_CENTER_BIT);&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;每一部分向左的位移&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;static&nbsp;long&nbsp;MACHINE_LEFT&nbsp;=&nbsp;SEQUENCE_BIT;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;static&nbsp;long&nbsp;DATA_CENTER_LEFT&nbsp;=&nbsp;SEQUENCE_BIT&nbsp;+&nbsp;MACHINE_BIT;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;final&nbsp;static&nbsp;long&nbsp;TIMESTAMP_LEFT&nbsp;=&nbsp;DATA_CENTER_LEFT&nbsp;+&nbsp;DATA_CENTER_BIT;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;dataCenterId;&nbsp;&nbsp;//数据中心&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;machineId;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//机器标识&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;sequence&nbsp;=&nbsp;0L;&nbsp;//序列号&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;lastTimeStamp&nbsp;=&nbsp;-1L;&nbsp;&nbsp;//上一次时间戳&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;getNextMill()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;mill&nbsp;=&nbsp;getNewTimeStamp();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while&nbsp;(mill&nbsp;&lt;=&nbsp;lastTimeStamp)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mill&nbsp;=&nbsp;getNewTimeStamp();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;mill;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;long&nbsp;getNewTimeStamp()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;System.currentTimeMillis();&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;根据指定的数据中心ID和机器标志ID生成指定的序列号&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;dataCenterId&nbsp;数据中心ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@param&nbsp;machineId&nbsp;&nbsp;&nbsp;&nbsp;机器标志ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;SnowFlakeShortUrl(long&nbsp;dataCenterId,&nbsp;long&nbsp;machineId)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(dataCenterId&nbsp;&gt;&nbsp;MAX_DATA_CENTER_NUM&nbsp;||&nbsp;dataCenterId&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException("DtaCenterId&nbsp;can't&nbsp;be&nbsp;greater&nbsp;than&nbsp;MAX_DATA_CENTER_NUM&nbsp;or&nbsp;less&nbsp;than&nbsp;0！");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(machineId&nbsp;&gt;&nbsp;MAX_MACHINE_NUM&nbsp;||&nbsp;machineId&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;IllegalArgumentException("MachineId&nbsp;can't&nbsp;be&nbsp;greater&nbsp;than&nbsp;MAX_MACHINE_NUM&nbsp;or&nbsp;less&nbsp;than&nbsp;0！");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dataCenterId&nbsp;=&nbsp;dataCenterId;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.machineId&nbsp;=&nbsp;machineId;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;/**&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;产生下一个ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;@return&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;synchronized&nbsp;long&nbsp;nextId()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;currTimeStamp&nbsp;=&nbsp;getNewTimeStamp();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(currTimeStamp&nbsp;&lt;&nbsp;lastTimeStamp)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException("Clock&nbsp;moved&nbsp;backwards.&nbsp;&nbsp;Refusing&nbsp;to&nbsp;generate&nbsp;id");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(currTimeStamp&nbsp;==&nbsp;lastTimeStamp)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//相同毫秒内，序列号自增&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sequence&nbsp;=&nbsp;(sequence&nbsp;+&nbsp;1)&nbsp;&amp;&nbsp;MAX_SEQUENCE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//同一毫秒的序列数已经达到最大&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sequence&nbsp;==&nbsp;0L)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;currTimeStamp&nbsp;=&nbsp;getNextMill();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//不同毫秒内，序列号置为0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sequence&nbsp;=&nbsp;0L;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastTimeStamp&nbsp;=&nbsp;currTimeStamp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;(currTimeStamp&nbsp;-&nbsp;START_TIMESTAMP)&nbsp;&lt;&lt;&nbsp;TIMESTAMP_LEFT&nbsp;//时间戳部分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;dataCenterId&nbsp;&lt;&lt;&nbsp;DATA_CENTER_LEFT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//数据中心部分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;machineId&nbsp;&lt;&lt;&nbsp;MACHINE_LEFT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//机器标识部分&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;sequence;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//序列号部分&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SnowFlakeShortUrl&nbsp;snowFlake&nbsp;=&nbsp;new&nbsp;SnowFlakeShortUrl(2,&nbsp;3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;(1&nbsp;&lt;&lt;&nbsp;4);&nbsp;i++)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//10进制&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(snowFlake.nextId());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 7、百度（uid-generator） uid-generator是由百度技术部开发，项目GitHub地址 https://github.com/baidu/uid-generator uid-generator是基于Snowflake算法实现的，与原始的snowflake算法不同在于，uid-generator支持自定义时间戳、工作机器ID和 序列号 等各部分的位数，而且uid-generator中采用用户自定义workId的生成策略。 uid-generator需要与数据库配合使用，需要新增一个WORKER_NODE表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的workId数据由host，port组成。 对于uid-generator ID组成结构： workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，而且同一应用每次重启就会消费一个workId。 参考文献https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md 8、美团（Leaf） Leaf由美团开发，github地址：https://github.com/Meituan-Dianping/Leaf Leaf同时支持号段模式和snowflake算法模式，可以切换使用。 号段模式 先导入源码 https://github.com/Meituan-Dianping/Leaf ，在建一张表leaf_alloc DROP&nbsp;TABLE&nbsp;IF&nbsp;EXISTS&nbsp;`leaf_alloc`;CREATE&nbsp;TABLE&nbsp;`leaf_alloc`&nbsp;(&nbsp;&nbsp;`biz_tag`&nbsp;varchar(128)&nbsp;&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;''&nbsp;COMMENT&nbsp;'业务key',&nbsp;&nbsp;`max_id`&nbsp;bigint(20)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'1'&nbsp;COMMENT&nbsp;'当前已经分配了的最大id',&nbsp;&nbsp;`step`&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;'初始步长，也是动态调整的最小步长',&nbsp;&nbsp;`description`&nbsp;varchar(256)&nbsp;&nbsp;DEFAULT&nbsp;NULL&nbsp;COMMENT&nbsp;'业务key的描述',&nbsp;&nbsp;`update_time`&nbsp;timestamp&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;CURRENT_TIMESTAMP&nbsp;ON&nbsp;UPDATE&nbsp;CURRENT_TIMESTAMP&nbsp;COMMENT&nbsp;'数据库维护的更新时间',&nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(`biz_tag`))&nbsp;ENGINE=InnoDB; 然后在项目中开启号段模式，配置对应的数据库信息，并关闭snowflake模式 leaf.name=com.sankuai.leaf.opensource.testleaf.segment.enable=trueleaf.jdbc.url=jdbc:mysql://localhost:3306/leaf_test?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8leaf.jdbc.username=rootleaf.jdbc.password=rootleaf.snowflake.enable=false#leaf.snowflake.zk.address=#leaf.snowflake.port= 启动leaf-server 模块的 LeafServerApplication项目就跑起来了 号段模式获取分布式自增ID的测试url ：http：//localhost：8080/api/segment/get/leaf-segment-test 监控号段模式：http://localhost:8080/cache snowflake模式 Leaf的snowflake模式依赖于ZooKeeper，不同于原始snowflake算法也主要是在workId的生成上，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。 leaf.snowflake.enable=trueleaf.snowflake.zk.address=127.0.0.1leaf.snowflake.port=2181 snowflake模式获取分布式自增ID的测试url：http://localhost:8080/api/snowflake/get/test 9、滴滴（Tinyid） Tinyid由滴滴开发，Github地址：https://github.com/didi/tinyid。 Tinyid是基于号段模式原理实现的与Leaf如出一辙，每个服务获取一个号段（1000,2000]、（2000,3000]、（3000,4000] Tinyid提供http和tinyid-client两种方式接入 Http方式接入 （1）导入Tinyid源码： git clone https://github.com/didi/tinyid.git （2）创建数据表： CREATE&nbsp;TABLE&nbsp;`tiny_id_info`&nbsp;(&nbsp;&nbsp;`id`&nbsp;bigint(20)&nbsp;unsigned&nbsp;NOT&nbsp;NULL&nbsp;AUTO_INCREMENT&nbsp;COMMENT&nbsp;'自增主键',&nbsp;&nbsp;`biz_type`&nbsp;varchar(63)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;''&nbsp;COMMENT&nbsp;'业务类型，唯一',&nbsp;&nbsp;`begin_id`&nbsp;bigint(20)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同',&nbsp;&nbsp;`max_id`&nbsp;bigint(20)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'当前最大id',&nbsp;&nbsp;`step`&nbsp;int(11)&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'步长',&nbsp;&nbsp;`delta`&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'1'&nbsp;COMMENT&nbsp;'每次id增量',&nbsp;&nbsp;`remainder`&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'余数',&nbsp;&nbsp;`create_time`&nbsp;timestamp&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'2010-01-01&nbsp;00:00:00'&nbsp;COMMENT&nbsp;'创建时间',&nbsp;&nbsp;`update_time`&nbsp;timestamp&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'2010-01-01&nbsp;00:00:00'&nbsp;COMMENT&nbsp;'更新时间',&nbsp;&nbsp;`version`&nbsp;bigint(20)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'版本号',&nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(`id`),&nbsp;&nbsp;UNIQUE&nbsp;KEY&nbsp;`uniq_biz_type`&nbsp;(`biz_type`))&nbsp;ENGINE=InnoDB&nbsp;AUTO_INCREMENT=1&nbsp;DEFAULT&nbsp;CHARSET=utf8&nbsp;COMMENT&nbsp;'id信息表';CREATE&nbsp;TABLE&nbsp;`tiny_id_token`&nbsp;(&nbsp;&nbsp;`id`&nbsp;int(11)&nbsp;unsigned&nbsp;NOT&nbsp;NULL&nbsp;AUTO_INCREMENT&nbsp;COMMENT&nbsp;'自增id',&nbsp;&nbsp;`token`&nbsp;varchar(255)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;''&nbsp;COMMENT&nbsp;'token',&nbsp;&nbsp;`biz_type`&nbsp;varchar(63)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;''&nbsp;COMMENT&nbsp;'此token可访问的业务类型标识',&nbsp;&nbsp;`remark`&nbsp;varchar(255)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;''&nbsp;COMMENT&nbsp;'备注',&nbsp;&nbsp;`create_time`&nbsp;timestamp&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'2010-01-01&nbsp;00:00:00'&nbsp;COMMENT&nbsp;'创建时间',&nbsp;&nbsp;`update_time`&nbsp;timestamp&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'2010-01-01&nbsp;00:00:00'&nbsp;COMMENT&nbsp;'更新时间',&nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(`id`))&nbsp;ENGINE=InnoDB&nbsp;AUTO_INCREMENT=1&nbsp;DEFAULT&nbsp;CHARSET=utf8&nbsp;COMMENT&nbsp;'token信息表';INSERT&nbsp;INTO&nbsp;`tiny_id_info`&nbsp;(`id`,&nbsp;`biz_type`,&nbsp;`begin_id`,&nbsp;`max_id`,&nbsp;`step`,&nbsp;`delta`,&nbsp;`remainder`,&nbsp;`create_time`,&nbsp;`update_time`,&nbsp;`version`)VALUES&nbsp;&nbsp;&nbsp;&nbsp;(1,&nbsp;'test',&nbsp;1,&nbsp;1,&nbsp;100000,&nbsp;1,&nbsp;0,&nbsp;'2018-07-21&nbsp;23:52:58',&nbsp;'2018-07-22&nbsp;23:19:27',&nbsp;1);INSERT&nbsp;INTO&nbsp;`tiny_id_info`&nbsp;(`id`,&nbsp;`biz_type`,&nbsp;`begin_id`,&nbsp;`max_id`,&nbsp;`step`,&nbsp;`delta`,&nbsp;`remainder`,&nbsp;`create_time`,&nbsp;`update_time`,&nbsp;`version`)VALUES&nbsp;&nbsp;&nbsp;&nbsp;(2,&nbsp;'test_odd',&nbsp;1,&nbsp;1,&nbsp;100000,&nbsp;2,&nbsp;1,&nbsp;'2018-07-21&nbsp;23:52:58',&nbsp;'2018-07-23&nbsp;00:39:24',&nbsp;3);INSERT&nbsp;INTO&nbsp;`tiny_id_token`&nbsp;(`id`,&nbsp;`token`,&nbsp;`biz_type`,&nbsp;`remark`,&nbsp;`create_time`,&nbsp;`update_time`)VALUES&nbsp;&nbsp;&nbsp;&nbsp;(1,&nbsp;'0f673adf80504e2eaa552f5d791b644c',&nbsp;'test',&nbsp;'1',&nbsp;'2017-12-14&nbsp;16:36:46',&nbsp;'2017-12-14&nbsp;16:36:48');INSERT&nbsp;INTO&nbsp;`tiny_id_token`&nbsp;(`id`,&nbsp;`token`,&nbsp;`biz_type`,&nbsp;`remark`,&nbsp;`create_time`,&nbsp;`update_time`)VALUES&nbsp;&nbsp;&nbsp;&nbsp;(2,&nbsp;'0f673adf80504e2eaa552f5d791b644c',&nbsp;'test_odd',&nbsp;'1',&nbsp;'2017-12-14&nbsp;16:36:46',&nbsp;'2017-12-14&nbsp;16:36:48'); （3）配置数据库： datasource.tinyid.names=primarydatasource.tinyid.primary.driver-class-name=com.mysql.jdbc.Driverdatasource.tinyid.primary.url=jdbc:mysql://ip:port/databaseName?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8datasource.tinyid.primary.username=rootdatasource.tinyid.primary.password=123456 （4）启动tinyid-server后测试 获取分布式自增ID:&nbsp;http://localhost:9999/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c'返回结果:&nbsp;3批量获取分布式自增ID:http://localhost:9999/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c&amp;batchSize=10'返回结果:&nbsp;&nbsp;4,5,6,7,8,9,10,11,12,13 Java客户端方式接入 重复Http方式的（2）（3）操作 引入依赖 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;dependency&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;com.xiaoju.uemc.tinyid&lt;/groupId&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId&gt;tinyid-client&lt;/artifactId&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;${tinyid.version}&lt;/version&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/dependency&gt; 配置文件 tinyid.server&nbsp;=localhost:9999tinyid.token&nbsp;=0f673adf80504e2eaa552f5d791b644c test 、tinyid.token是在数据库表中预先插入的数据，test 是具体业务类型，tinyid.token表示可访问的业务类型 //&nbsp;获取单个分布式自增IDLong&nbsp;id&nbsp;=&nbsp;&nbsp;TinyId&nbsp;.&nbsp;nextId(&nbsp;"&nbsp;test&nbsp;"&nbsp;);//&nbsp;按需批量分布式自增IDList&lt;&nbsp;Long&nbsp;&gt;&nbsp;ids&nbsp;=&nbsp;&nbsp;TinyId&nbsp;.&nbsp;nextId(&nbsp;"&nbsp;test&nbsp;"&nbsp;,&nbsp;10&nbsp;); 总结 本文只是简单介绍一下每种分布式ID生成器，旨在给大家一个详细学习的方向，每种生成方式都有它自己的优缺点，具体如何使用还要看具体的业务需求。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识数据埋点]]></title>
    <url>%2F2020%2F01%2F19%2F7.%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%2F</url>
    <content type="text"><![CDATA[前言 如今，数据已成为一个企业重要的财富，90%的市场决策和经营决策都是通过数据分析研究确定的。对数据分析师来说，好的数据源，是数据分析的根基。在整个数据分析流程中，数据采集，是整个数据流的起点，也是最重要的环节之一。采集到的数据质量与准确性直接决定数据广度和质量，影响整个分析报告的所有环节。 在获得高质量数据的过程中，数据埋点这一动作尤为必要，这是针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程。今天我们来说说如何做好数据埋点，为收集优质数据垒实基础。 一.什么是数据埋点 所谓埋点是数据领域的专业术语，也是互联网应用里的一个俗称。它的学名应该叫做事件追踪，对应的英文是Event Tracking。它主要是针对特定用户行为或事件进行捕获、处理和发送的相关技术及其实施过程。 当用户的行为满足某种条件的时候，比如进入某个页面、点击某个按钮等，会自动触发记录和存储，然后这些数据会被收集并被传输到终端提供商，或者是通过后端采集用户使用服务过程中的请求数据。 一个典型的埋点采集处理流程如下图所示： 二、为什么要做数据埋点 埋点就是为了对产品进行持续追踪，通过深度数据分析不断优化产品。好比去医院体检，医生测了你身体的各个健康指标，以此来判断你的健康状况。埋点的目的，其实就是随时或者定期监测你的产品的“健康”状况。 任何一个系统在设计初始阶段只关心核心业务的功能，等到系统上线以后，数据分析师对用户行为分析时会发现缺少很多数据，此时需要采用埋点的方法进行采集需要的数据。 业务人员主要通过自有或第三方的数据统计平台了解产品的概览性数据指标，包括新增用户数、活跃用户数等。这些指标能帮助企业宏观的了解用户访问的整体情况和趋势，从整体上把握产品的运营状况，但很难基于这些指标直接得到切实的产品改进策略。 而埋点将产品数据分析的深度下钻到流量分布和流动层面，通过对产品中的用户交互行为的统计分析，对宏观指标进行深入剖析，发现指标背后的问题，寻找人群的行为特点和关系，洞察用户行为与提升业务价值之间的潜在关联，了解组成特定数据现象的原因，并据此构建产品优化迭代和运营策略。 对于产品来说，用户在你的产品里做了什么、停留了多久、有什么异样，都是需要关注的。比如用户点击率怎么样？用户在核心使用路径上是否顺畅？有没有得到用户的认可？有没有因为设计按钮过多导致用户行为无效？用户希望有什么样的功能更新等等问题都可以通过埋点的方法实现。 埋点做好才能用来进行数据驱动产品和精细化运营。而埋点质量的好坏也直接影响到了产品运营的质量。因此它贯穿了产品的整个生命周期，为产品优化指明了方向。所以说，好的数据埋点，就成功了一半。 三.数据埋点的分类 数据埋点具体的方式有三种：代码埋点（手动埋点）、可视化埋点、无埋点（全埋点）。如果从系统的前后端来讲，埋点又分为前端埋点和后端埋点。无埋点是前端埋点，而代码埋点既是前端埋点又是后端埋点。 1.代码埋点 在你需要统计数据的关键部位植入N行代码，追踪用户的关键行为，得到想要的数据。简单的说，就是找节点，布代码，收数据。又分为前端代码埋点和后端代码埋点。它是手动编码产生的，自由度高，功能强大，企业可以自定义事件和属性，精准控制监控对象，传输丰富的数据内容。 前端埋点 前端埋点能够收集更全面、精细的用户数据，尤其是不需要请求服务器的行为数据，如：页面停留时长、页面浏览深度、视频播放时长、用户鼠标轨迹、表单项停留及终止等等，只能通过前端埋点实现。但缺点在于，前端埋点的上报一般存在 15% 左右的延迟上报和漏报（客户端未联网、数据打包上报、用户删除行为数据等原因）。另外，如果客户端是 APP，每次上线新的埋点或者更新埋点时，需要发布新的版本才行，但是会存在部分用户不更新版本情况，影响数据质量。 后端埋点 理论上，只要客户端向服务器发送过请求，服务端埋点能够收集到。相比于前端埋点，能实时采集数据，不存在延时上报，数据很准确；并且，服务端埋点支持与用户身份信息和行为附带属性信息整合；另外，每次上线新的埋点或者更新埋点时，发布后马上生效。代码埋点适合精细化分析的场景，我们可以将各种细粒度的数据采集下来，后续做深度分析。当然这种埋点方式很低效，需要经历完整的埋点流程，包括业务梳理（产品运营）、埋点设计（产品运营/研发）、实施/测试/上线埋点（研发/测试）。整个过程需要多方协作，且要求产品运营也具备一定的专业水平，如果发生错漏无法快速补救。 （1）优点： ①采集的数据比较具有针对性，更加适合精细化数据分析； ②同时也能提高数据的准确性。 （2）缺点： ①每一个控件的埋点都需要添加相应的代码，不仅工作量大，而且限定了必须是技术开发人员才能完成； ②每一次产品迭代，都需要更新埋点方案。 （3）适用场景： ①有具体的业务分析需求，且按照各个事件埋点的方式不能满足； ②需要对埋点事件进行传参等自定义属性设置。代码埋点虽然较复杂，但功能最完善，覆盖了埋点中的不同业务需求。 2.可视化埋点 由于代码埋点需要终端开发人员来执行采集方案，对业务的功能开发侵入性较高。有的公司开发出了可视化埋点技术，只需要产品与运营人员通过GUI界面进行鼠标简单点击，就可以随时增加、取消、调整采集数据的位置和方式。比如国外比较早做可视化的是 Mixpanel，国内较早支持可视化埋点的有TalkingData、诸葛 IO，2017年腾讯的 MTA 也宣布支持可视化埋点；相比于手动埋点更新困难，埋点成本高的问题，可视化埋点优化了移动运营中数据采集的流程，避开了终端开发人员的介入，由需求人员直接执行采集，减轻了需求传递过程中的信息损耗和误解，另外可视化埋点技术往往由服务端直接下发采集的配置文件，而不用走发版流程，从而加快了数据采集的流程。 （1）优点： ①业务人员可用，无需技术人员进行SDK嵌入，不懂代码的产品运营人员也可通过后台可视化界面配置和统计埋点并实时下发到客户端生效； ②无需版本更新，由于不需要嵌入新SDK，不需要发布新版本，可谓即时生效； ③对所有版本生效：新增埋点在所有版本生效，不存在迭代问题。 （2）缺点： ①可覆盖的功能有限，目前并不是所有控件操作都可以通过这种方案进行定制； ②不能自定义交互事件属性，由于获取的是交互事件元素的DOMpath，无法对具体事件设置参数； ③不支持可以不断加载的内容瀑布流交互。 （3）适用场景： ①分析或统计需求简单，不需要对埋点事件进行传参等自定义属性设置； ②频繁上线或更新的H5类型的运营活动 3.无埋点 无埋点又被称为全埋点，是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。使用这种方案，每次有用户行为分析的需求，不用再走一次完整的埋点流程，只用在产品中嵌入 SDK，等于做了一个统一的埋点。国内GrowingIO在2015年也较早支持了无埋点方案，后面神策等其他第三方也陆续支持了此技术。 （1）优点： ①因为无埋点对页面所有元素进行埋点，那么这个页面每个元素被点击的概率你也就知道，对点击概率比较大的元素可以进行深入分析； ②可以在系统上线后使用，支持基于全量的数据回溯，因为无埋点在你部署SDK的时候数据就一直在收集，可帮助进行启发式、探索式的数据分析； ③它技术门槛低，部署简单。 （2）缺点： ①无埋点无法采集自定义属性，只使用通用的场景； ②数据形式非业务导向，因为是对所有事件数据的自动收集，没有按照业务需求进行事件或区域设置，业务或数据人员在使用时或许不能直接使用，需要二次计算或处理； ③兼容性不好，传输时效性较差等问题，因为是对所有的元素数据都收集，会给数据传输和服务器带来较大的压力。 （3）适用场景： ①分析或统计需求简单，不需要对埋点事件进行传参等自定义属性设置的事件； ②针对快速、频繁上线和迭代的H5类型的运营活动的评估 无埋点相比可视化埋点，在解决数据“回溯”问题上更有优势，如果你想分析某一天某个控件的点击情况，如果你没有针对这个按钮做可视化埋点，则只能从你针对这个按钮做可视化配置的这一时刻之后才有埋点数据，而无埋点，则从你部署SDK那一刻就一直有数据在收集；无埋点做热力图也更有优势，无埋点可以告诉使用者这个界面上每个控件分别被点击的概率是多大，通过热力图清晰可见。 无埋点确实发送的埋点数量很巨大，比如知乎上就有很多人质疑无埋点解决方案。很多用户对无埋点发送大量埋点请求表示不理解，但是由于无埋点技术方案的限制，无埋点的可交互元素众多，每一次交互都会发送请求，所以会导致网络请求过重。神策等官方文档中也建议无埋点最好使用在那些按钮不是很多的，相对简单的页面。 总结 埋点方式 优点 缺点 适用场景 代码埋点-前端 1. 能收集非常全面的、精细的用户行为数据，尤其是不需要请求服务器的行为，只能使用前端埋点 1. 无网络时数据不完整、实时性有延迟；2. 当需要改变埋点时，必须更新版本（APP） 需要最大幅度的、全面的、精细的记录用户在客户端的行为 代码埋点-后端 1. 实时采集数据，精准；2. 支持与用户身份信息和行为附带属性信息整合；3. 变更成本低；4.能够收集不在APP内发生的行为，只要请求服务器就行。如统计从其他APP引流的安装量 1. 不能收集不需要请求服务器的数据；2. 用户不联网不能采集数据 需要整合用户身份信息和行为属性信息的埋点，并且对于前后端都能采集的，优先选择后端 可视化埋点 1. 无需研发人员介入；2. 不需要发布新版本，即时生效；3. 对所有版本生效：新增埋点在所有版本生效，不存在迭代问题 可覆盖的功能有限，目前并不是所有控件操作都可以通过这种方案进行定制 产品业务相对简单，可视化埋点配置化能力相对手动埋点更强，是对手动埋点的补充而不是代替，很多手动埋点点都可以通过好的规划和架构变为可视化埋点 无埋点 每次有用户行为分析的需求，不用再走一次完整的埋点流程，只用在产品中嵌入 SDK，等于做了一个统一的埋点 全埋点采集的数据量非常大，随着数据量上升，可能会导致客户端崩溃的概率也会上升。尤其是移动端，更多的数据量意味着更多的电量、流量和内存消耗；第三，即使全部行为数据都被收集回来了，具体分析时也不能避免二次梳理和加工 无埋点最好使用在那些按钮不是很多的，相对简单的页面 四.如何做数据埋点 如果你想绘制基础的人群画像你就需要获取用户机型、网络类型、操作系统，IP地域等数据；如果你想分析每一个注册转化率，你就需要获取每一个步骤的点击次数，然后制作成漏斗，看那一步转化率出现了问题……目的不一样，获取的数据也不一样，使用的埋点技术也不一样。 那么，我们该如何选择埋点方式呢？ 我们的目的是实现深度数据分析，不应该采用与其他企业通用的埋点方法，应该采用适合自己的埋点方法。也就是做到“因系统而异、避免千系统一面的情况。 在系统刚上线的初期阶段，我们可以采用无埋点的方式。因为我们通过UV、PV、点击率等基本指标及即可满足数据分析需求。如果产品上线时间很长，我们需要进行深度数据分析则选择代码埋点。它可以帮我们收集需要的属性。另外，如何埋点既可以在前端实现，也可以在后端实现，我们推荐在后端实现。因为后端数据可以保证数据的准确性。最后，如果您为了方便快捷并且免费，可以选择第三方统计工具，但是一定要选择适合自己业务的统计工具。 从业务过程中采集埋点，是数据驱动型公司的必要条件。一般公司的产品功能评审环节，不仅有 PRD (Product requirement document），还加入了对应的 DRD ( Data requirement document）。对于埋点而言，DRD 需要明确业务目标与埋点缺口之间的关系以及需求的优先级。埋点的需求大多来自于 DRD，整个过程会涉及多个角色，主要包括产品经理、业务数据负责人、开发工程师、测试工程师。 总之，如果需要深度分析，选择后端（手动）埋点和无埋点组合的方案；如果您只是想看宏观数据，可以选择无埋点。无论采用哪种埋点方法，一定要慎重，根据需要来设置，最好不要出现错埋或者漏埋的情况。最后，数据分析师一定要和业务工程团队（部署实施埋点的部门）配合好才能实现完美的数据采集方案，有时候沟通比选择埋点方式更重。 常见的埋点平台参考： growing io： https://www.growingio.com/神策： https://www.sensorsdata.cn/诸葛ＩＯ： https://zhugeio.com/talking data: http://www.talkingdata.com/友盟： https://developer.umeng.com百度统计： https://mtj.baidu.com/web/welcome/loginGoogle Analytics: https://analytics.google.com数猎天下DataHunter：https://www.datahunter.cn/]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识JVM]]></title>
    <url>%2F2020%2F01%2F10%2F6.%E5%88%9D%E8%AF%86JVM%2F</url>
    <content type="text"><![CDATA[前言 如果在文中用词或者理解方面出现问题，欢迎指出。此文旨在提及和而不深究，但会尽量效率地把知识点都抛出来 一、JVM的基本介绍 JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现··· 好，其实抛开这么专业的句子不说，就知道JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，可操作系统可以帮我们完成和硬件进行交互的工作。 1.1 Java文件是如何被运行的 比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。 那我们的 JVM 是不认识文本文件的，所以它需要一个 编译 ，让其成为一个它会读二进制文件的 HelloWorld.class ① 类加载器 如果 JVM 想要执行这个 .class 文件，我们需要将其装进一个 类加载器 中，它就像一个搬运工一样，会把所有的 .class 文件全部搬进JVM里面来。 ② 方法区 方法区 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等 类加载器将 .class 文件搬过来就是先丢到这一块上 ③ 堆 堆 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 线程共享区域 。也就是说它们都是 线程不安全 的 ④ 栈 栈 这是我们的代码运行空间。我们编写的每一个方法都会放到 栈 里面运行。 我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用C来进行工作的，和Java没有太大的关系。 ⑤ 程序计数器 主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 线程独享 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。 小总结 Java文件经过编译后变成 .class 字节码文件 字节码文件通过类加载器被搬运到 JVM 虚拟机中 虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行 1.2 简单的代码例子 一个简单的学生类 一个main方法 执行main方法的步骤如下: 编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载 JVM 找到 App 的主程序入口，执行main方法 这个main中的第一条语句为 Student student = new Student("tellUrDream") ，就是让 JVM 创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中 加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 指向方法区中的 Student 类的类型信息 的引用 执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。 执行sayName() 其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。 二、类加载器的介绍 之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由 Execution Engine 来决定 2.1 类加载器的流程 从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中验证，准备，解析三个部分统称为连接 2.1.1 加载 将class文件加载到内存 将静态数据结构转化成方法区中运行时的数据结构 在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口 2.1.2 链接 验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查 准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的） 解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行） 2.1.3 初始化 初始化其实就是一个赋值的操作，它会执行一个类构造器的()方法。由编译器自动收集类中所有变量的赋值动作，此时准备阶段时的那个 static int a = 3 的例子，在这个时候就正式赋值为3 2.1.4 卸载 GC将无用对象从内存中卸载 2.2 类加载器的加载顺序 加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的 BootStrap ClassLoader：rt.jar Extention ClassLoader: 加载扩展的jar包 App ClassLoader：指定的classpath下面的jar包 Custom ClassLoader：自定义的类加载器 2.3 双亲委派机制 当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要new一个Person，这个Person是我们自定义的类，如果我们要加载它，就会先委派App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载 这样做的好处是，加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到BootStrap ClassLoader进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。 其实这个也是一个隔离的作用，避免了我们的代码影响了JDK的代码，比如我现在要来一个 public&nbsp;class&nbsp;String(){&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(){sout;}}复制代码 这种时候，我们的代码肯定会报错，因为在加载的时候其实是找到了rt.jar中的String.class，然后发现这也没有main方法 三、运行时数据区 3.1 本地方法栈和程序计数器 比如说我们现在点开Thread类的源码，会看到它的start0方法带有一个native关键字修饰，而且不存在方法体，这种用native修饰的方法就是本地方法，这是使用C来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。 程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。 如果执行的是native方法，那这个指针就不工作了。 3.2 方法区 方法区主要的作用技术存放类的元数据信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。 3.3 虚拟机栈和虚拟机堆 一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。 3.3.1 虚拟机栈的概念 它是Java方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈 public&nbsp;class&nbsp;Person{&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;a&nbsp;=&nbsp;1;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;doSomething(){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;b&nbsp;=&nbsp;2;&nbsp;&nbsp;&nbsp;&nbsp;}}复制代码 3.3.2 虚拟机栈存在的异常 如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 StackOverflowError （这种错误经常出现在递归中）。Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 OutOfMemoryError。 3.3.3 虚拟机栈的生命周期 对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。 这里补充一句：8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。 3.3.4 虚拟机栈的执行 我们经常说的栈帧数据，说白了在JVM中叫栈帧，放到Java中其实就是方法，它也是存放在栈中的。 栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法a，就会对应产生一个栈帧A1，然后A1会被压入栈中。同理方法b会有一个B1，方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1,A1。它是一个先进后出，后进先出原则。 3.3.5 局部变量的复用 局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以Slot为最小单位，一个slot可以存放32位以内的数据类型。 虚拟机通过索引定位的方式使用局部变量表，范围为[0,局部变量表的slot的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些slot是可以复用的，当方法执行位置超过了某个变量，那么这个变量的slot可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。 3.3.6 虚拟机堆的概念 JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为年轻代和老年代，而非堆内存则为永久代。年轻代又会分为Eden和Survivor区。Survivor也会分为FromPlace和ToPlace，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 8:1:1。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整 堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给GC算法进行回收。非堆内存其实我们已经说过了，就是方法区。在1.8中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是metaSpace是不存在于JVM中的，它使用的是本地内存。并有两个参数 MetaspaceSize：初始化元空间大小，控制发生GCMaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。复制代码 移除的原因可以大致了解一下：融合HotSpot JVM和JRockit VM而做出的改变，因为JRockit是没有永久代的，不过这也间接性地解决了永久代的OOM问题。 3.3.7 Eden年轻代的介绍 当我们new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是每个线程都会预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作TLAB，有兴趣可以了解一下。 当Eden空间满了之后，会触发一个叫做Minor GC（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 Minor GC，就会将存活对象移动到Survivor1区，此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。经过多次的 Minor GC后仍然存活的对象（这里的存活判断是15次，对应到虚拟机参数为 -XX:TargetSurvivorRatio 。为什么是15，因为HotSpot会在对象投中的标记字段里记录年龄，分配到的空间仅有4位，所以最多只能记录到15）会移动到老年代。老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，期间会停止所有线程等待GC的完成。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。 而且当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xms来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。 3.3.8 如何判断一个对象需要被干掉 图中程序计数器、虚拟机栈、本地方法栈，3个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而Java堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。 在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法 1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。 2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如Java，C#等都是靠这招去判定对象是否存活的。 （了解一下即可）在Java语言汇总能作为GC Roots的对象分为以下几种： 虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量） 方法区中静态变量所引用的对象（静态变量） 方法区中常量引用的对象 本地方法栈（即native修饰的方法）中JNI引用的对象（JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收） 已启动的且未终止的Java线程 这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程） 3.3.9 如何宣告一个对象的真正死亡 首先必须要提到的是一个名叫 finalize() 的方法 finalize()是Object类的一个方法、一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用。 补充一句：并不提倡在程序中调用finalize()来进行自救。建议忘掉Java程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在Java9中已经被标记为 deprecated ，且java.lang.ref.Cleaner（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比finalize来的更加的轻量及可靠。 判断一个对象的死亡至少需要两次标记 如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。 GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。 如果确定对象已经死亡，我们又该如何回收这些垃圾呢 3.4 垃圾回收算法 不会非常详细的展开，常用的有标记清除，复制，标记整理和分代收集算法 3.4.1 标记清除算法 标记清除算法就是分为“标记”和“清除”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础来加以改进的。 其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。 不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图 此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题 3.4.2 复制算法 为了解决效率问题，复制算法就出现了。它将可用内存按容量划分成两等分，每次只使用其中的一块。和survivor一样也是用from和to两个指针这样的玩法。fromPlace存满了，就把存活的对象copy到另一块toPlace上，然后交换指针的内容。这样就解决了碎片的问题。 这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分低下了 不过它们分配的时候也不是按照1:1这样进行分配的，就类似于Eden和Survivor也不是等价分配是一个道理。 3.4.3 标记整理算法 复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存 3.4.4 分代收集算法 这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。 说白了就是八仙过海各显神通，具体问题具体分析了而已。 3.5 （了解）各种各样的垃圾回收器 HotSpot VM中的垃圾回收器，以及适用场景 到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old 从jdk9开始，G1收集器成为默认的垃圾收集器目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge 回收新生代停顿长达1.5秒。G1回收器回收同样大小的新生代只停顿0.2秒。 3.6 （了解）JVM的常用参数 JVM的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。 参数名称 含义 默认值 说明 -Xms 初始堆大小 物理内存的1/64(&lt;1GB) 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制. -Xmx 最大堆大小 物理内存的1/4(&lt;1GB) 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制 -Xmn 年轻代大小(1.4or lator) 注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 -XX:NewSize 设置年轻代大小(for 1.3/1.4) -XX:MaxNewSize 年轻代最大值(for 1.3/1.4) -XX:PermSize 设置持久代(perm gen)初始值 物理内存的1/64 -XX:MaxPermSize 设置持久代最大值 物理内存的1/4 -Xss 每个线程的堆栈大小 JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了 -XX:NewRatio 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。 -XX:SurvivorRatio Eden区与Survivor区的大小比值 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10 -XX:+DisableExplicitGC 关闭System.gc() 这个参数需要严格的测试 -XX:PretenureSizeThreshold 对象超过多大是直接在旧生代分配 0 单位字节 新生代采用Parallel ScavengeGC时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象. -XX:ParallelGCThreads 并行收集器的线程数 此值最好配置与处理器数目相等 同样适用于CMS -XX:MaxGCPauseMillis 每次年轻代垃圾回收的最长时间(最大暂停时间) 如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值. 其实还有一些打印及CMS方面的参数，这里就不以一一列举了 四、关于JVM调优的一些方面 根据刚刚涉及的jvm的知识点，我们可以尝试对JVM进行调优，主要就是堆内存那块 所有线程共享数据区大小=新生代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m。所以java堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用fullgc，所以老年代过小的话反而是会增多fullgc的）。此值对系统性能影响较大，Sun官方推荐配置为java堆的3/8。 4.1 调整最大堆内存和最小堆内存 -Xmx –Xms：指定java堆最大值（默认值是物理内存的1/4(&lt;1GB)）和初始java堆最小值（默认值是物理内存的1/64(&lt;1GB)) 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于40%了，JVM就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于70%，又会动态缩小不过不会小于–Xms。就这么简单 开发过程中，通常会将 -Xms 与 -Xmx两个参数的配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。 我们执行下面的代码 System.out.println("Xmx="&nbsp;+&nbsp;Runtime.getRuntime().maxMemory()&nbsp;/&nbsp;1024.0&nbsp;/&nbsp;1024&nbsp;+&nbsp;"M");&nbsp;&nbsp;&nbsp;&nbsp;//系统的最大空间System.out.println("free&nbsp;mem="&nbsp;+&nbsp;Runtime.getRuntime().freeMemory()&nbsp;/&nbsp;1024.0&nbsp;/&nbsp;1024&nbsp;+&nbsp;"M");&nbsp;&nbsp;//系统的空闲空间System.out.println("total&nbsp;mem="&nbsp;+&nbsp;Runtime.getRuntime().totalMemory()&nbsp;/&nbsp;1024.0&nbsp;/&nbsp;1024&nbsp;+&nbsp;"M");&nbsp;&nbsp;//当前可用的总空间复制代码 注意：此处设置的是Java堆大小，也就是新生代大小 + 老年代大小 设置一个VM options的参数 -Xmx20m&nbsp;-Xms5m&nbsp;-XX:+PrintGCDetails复制代码 再次启动main方法 这里GC弹出了一个Allocation Failure分配失败，这个事情发生在PSYoungGen，也就是年轻代中 这时候申请到的内存为18M，空闲内存为4.214195251464844M 我们此时创建一个字节数组看看，执行下面的代码 byte[]&nbsp;b&nbsp;=&nbsp;new&nbsp;byte[1&nbsp;*&nbsp;1024&nbsp;*&nbsp;1024];System.out.println("分配了1M空间给数组");System.out.println("Xmx="&nbsp;+&nbsp;Runtime.getRuntime().maxMemory()&nbsp;/&nbsp;1024.0&nbsp;/&nbsp;1024&nbsp;+&nbsp;"M");&nbsp;&nbsp;//系统的最大空间System.out.println("free&nbsp;mem="&nbsp;+&nbsp;Runtime.getRuntime().freeMemory()&nbsp;/&nbsp;1024.0&nbsp;/&nbsp;1024&nbsp;+&nbsp;"M");&nbsp;&nbsp;//系统的空闲空间System.out.println("total&nbsp;mem="&nbsp;+&nbsp;Runtime.getRuntime().totalMemory()&nbsp;/&nbsp;1024.0&nbsp;/&nbsp;1024&nbsp;+&nbsp;"M");复制代码 此时free memory就又缩水了，不过total memory是没有变化的。Java会尽可能将total mem的值维持在最小堆内存大小 byte[]&nbsp;b&nbsp;=&nbsp;new&nbsp;byte[10&nbsp;*&nbsp;1024&nbsp;*&nbsp;1024];System.out.println("分配了10M空间给数组");System.out.println("Xmx="&nbsp;+&nbsp;Runtime.getRuntime().maxMemory()&nbsp;/&nbsp;1024.0&nbsp;/&nbsp;1024&nbsp;+&nbsp;"M");&nbsp;&nbsp;//系统的最大空间System.out.println("free&nbsp;mem="&nbsp;+&nbsp;Runtime.getRuntime().freeMemory()&nbsp;/&nbsp;1024.0&nbsp;/&nbsp;1024&nbsp;+&nbsp;"M");&nbsp;&nbsp;//系统的空闲空间System.out.println("total&nbsp;mem="&nbsp;+&nbsp;Runtime.getRuntime().totalMemory()&nbsp;/&nbsp;1024.0&nbsp;/&nbsp;1024&nbsp;+&nbsp;"M");&nbsp;&nbsp;//当前可用的总空间复制代码 这时候我们创建了一个10M的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的total memory已经变成了15M，这就是已经申请了一次内存的结果。 此时我们再跑一下这个代码 System.gc();System.out.println("Xmx="&nbsp;+&nbsp;Runtime.getRuntime().maxMemory()&nbsp;/&nbsp;1024.0&nbsp;/&nbsp;1024&nbsp;+&nbsp;"M");&nbsp;&nbsp;&nbsp;&nbsp;//系统的最大空间System.out.println("free&nbsp;mem="&nbsp;+&nbsp;Runtime.getRuntime().freeMemory()&nbsp;/&nbsp;1024.0&nbsp;/&nbsp;1024&nbsp;+&nbsp;"M");&nbsp;&nbsp;//系统的空闲空间System.out.println("total&nbsp;mem="&nbsp;+&nbsp;Runtime.getRuntime().totalMemory()&nbsp;/&nbsp;1024.0&nbsp;/&nbsp;1024&nbsp;+&nbsp;"M");&nbsp;&nbsp;//当前可用的总空间复制代码 此时我们手动执行了一次fullgc，此时total memory的内存空间又变回5.5M了，此时又是把申请的内存释放掉的结果。 4.2 调整新生代和老年代的比值 -XX:NewRatio --- 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值 例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的1/5。在Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。 4.3 调整Survivor区和Eden区的比值 -XX:SurvivorRatio（幸存代）--- 设置两个Survivor区和eden的比值 例如：8，表示两个Survivor:eden=2:8，即一个Survivor占年轻代的1/10 4.4 设置年轻代和老年代的大小 -XX:NewSize --- 设置年轻代大小 -XX:MaxNewSize --- 设置年轻代最大值 可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的Eden和Survivor的占比为8:1:1，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的gc，需要注意。 4.5 小总结 根据实际事情调整新生代和幸存代的大小，官方推荐新生代占java堆的3/8，幸存代占新生代的1/10 在OOM时，记得Dump出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump文件，这个文件可以使用VisualVM或者Java自带的Java VisualVM工具。 -Xmx20m&nbsp;-Xms5m&nbsp;-XX:+HeapDumpOnOutOfMemoryError&nbsp;-XX:HeapDumpPath=你要输出的日志路径复制代码 一般我们也可以通过编写脚本的方式来让OOM出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。 4.6 永久区的设置 -XX:PermSize&nbsp;-XX:MaxPermSize复制代码 初始空间（默认为物理内存的1/64）和最大空间（默认为物理内存的1/4）。也就是说，jvm启动时，永久区一开始就占用了PermSize大小的空间，如果空间还不够，可以继续扩展，但是不能超过MaxPermSize，否则会OOM。 tips：如果堆空间没有用完也抛出了OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出OOM。 4.7 JVM的栈参数调优 4.7.1 调整每个线程栈空间的大小 可以通过-Xss：调整每个线程栈空间的大小 JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右 4.7.2 设置线程栈的大小 -XXThreadStackSize：&nbsp;&nbsp;&nbsp;&nbsp;设置线程栈的大小(0&nbsp;means&nbsp;use&nbsp;default&nbsp;stack&nbsp;size)复制代码 这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供demo了 4.8 (可以直接跳过了)JVM其他参数介绍 形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。 4.8.1 设置内存页的大小 -XXThreadStackSize：&nbsp;&nbsp;&nbsp;&nbsp;设置内存页的大小，不可设置过大，会影响Perm的大小复制代码 4.8.2 设置原始类型的快速优化 -XX:+UseFastAccessorMethods：&nbsp;&nbsp;&nbsp;&nbsp;设置原始类型的快速优化复制代码 4.8.3 设置关闭手动GC -XX:+DisableExplicitGC：&nbsp;&nbsp;&nbsp;&nbsp;设置关闭System.gc()(这个参数需要严格的测试)复制代码 4.8.4 设置垃圾最大年龄 -XX:MaxTenuringThreshold&nbsp;&nbsp;&nbsp;&nbsp;设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.&nbsp;&nbsp;&nbsp;&nbsp;对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,&nbsp;&nbsp;&nbsp;&nbsp;则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,&nbsp;&nbsp;&nbsp;&nbsp;增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.复制代码 4.8.5 加快编译速度 -XX:+AggressiveOpts复制代码 加快编译速度 4.8.6 改善锁机制性能 -XX:+UseBiasedLocking复制代码 4.8.7 禁用垃圾回收 -Xnoclassgc复制代码 4.8.8 设置堆空间存活时间 -XX:SoftRefLRUPolicyMSPerMB&nbsp;&nbsp;&nbsp;&nbsp;设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。复制代码 4.8.9 设置对象直接分配在老年代 -XX:PretenureSizeThreshold&nbsp;&nbsp;&nbsp;&nbsp;设置对象超过多大时直接在老年代分配，默认值是0。复制代码 4.8.10 设置TLAB占eden区的比例 -XX:TLABWasteTargetPercent&nbsp;&nbsp;&nbsp;&nbsp;设置TLAB占eden区的百分比，默认值是1%&nbsp;。&nbsp;复制代码 4.8.11设置是否优先YGC -XX:+CollectGen0First&nbsp;&nbsp;&nbsp;&nbsp;设置FullGC时是否先YGC，默认值是false。复制代码]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Canal实现MySql到ES数据全量与增量的同步]]></title>
    <url>%2F2019%2F11%2F17%2F5.%E5%9F%BA%E4%BA%8ECanal%E5%AE%9E%E7%8E%B0MySql%E5%88%B0ES%E6%95%B0%E6%8D%AE%E5%85%A8%E9%87%8F%E4%B8%8E%E5%A2%9E%E9%87%8F%E7%9A%84%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[前言 本文记录了基于Canal实现了mysql到es数据全量与增量的同步过程 背景 海量数据存储在MySql中，如果大量的查询和多样化的查询靠DB来支撑，那是很不友好的,所以我们引进了ElasticSearch来解决复杂和多样化查询，但也引出了下一个问题，数据如何同步？ 技术选型 目前数据的同步方案有三种 方案一：Canal监听MySql的Binlog，分析Binlog将数据同步到ES中（近实时）。 方案二：Logstash定时通过sql语句查询，实现增量更新（非实时）。 方案三：使用ElasticSearch API将数据写入ES中（近实时，但耦合度高）。 本文是基于方案一实现的 什么是canal？ 简介 canal是阿里巴巴 MySQL binlog 增量订阅&amp;消费组件，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。 工作原理 canal 模拟 mysql slave 的交互协议，伪装自己为 mysql slave ，向 mysql master 发送dump 协议 mysql master 收到 dump 请求，开始推送 binary log 给 slave (即 canal ) canal 解析 binary log 对象(原始为 byte 流) 官方文档：https://github.com/alibaba/canal 实现步骤 系统环境 MacOS Mojave 10.14.5 JDK 1.8.0_191 MySql 5.7.10 Elasticsearch 6.4.3 Kibana 6.4.3 Canal 1.1.4 一.安装mysql并开启mysql的binlog Canal的原理是基于MySql Binlog技术，所以这里一定需要开启MySql的Binlog写入功能，并且配置binlog模式为ROW 安装mysql的步骤本文不再赘述。 安装完mysql后如何查看binglog是否开启？ mysql&gt;&nbsp;show&nbsp;variables&nbsp;like&nbsp;'log_bin';+---------------+-------+|&nbsp;Variable_name&nbsp;|&nbsp;Value&nbsp;|+---------------+-------+|&nbsp;log_bin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;ON&nbsp;&nbsp;&nbsp;&nbsp;|+---------------+-------+ mysql&gt;&nbsp;show&nbsp;variables&nbsp;like&nbsp;'binlog_format';+---------------+-------+|&nbsp;Variable_name&nbsp;|&nbsp;Value&nbsp;|+---------------+-------+|&nbsp;binlog_format&nbsp;|&nbsp;ROW&nbsp;&nbsp;&nbsp;|+---------------+-------+ 如果log_bin = ON , binlog_format = ROW，表示正确。 若没有开启，则需要配置。找到my.cnf文件，我本地在/etc/my.cnf,在其中增加一段配置 [mysqld]log-bin=mysql-binbinlog-format=ROWserver_id=1 重启mysql服务，重新查看binlog是否开启。 二.安装并启动ElasticSearch 下载安装包 &nbsp;$&nbsp;wget&nbsp;https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.4.3.tar.gz 解压 &nbsp;$&nbsp;mkdir&nbsp;/user/local/elasticsearch&nbsp;$&nbsp;tar&nbsp;-zxvf&nbsp;elasticsearch-6.4.3.tar.gz&nbsp;-C&nbsp;/user/local/elasticsearch 解压后的目录如下 ----bin----config----data----lib----logs----modules----plugins 进入 bin 目录启动 ES &nbsp;$&nbsp;sh&nbsp;elasticsearch 检查ES服务是否正常启动 &nbsp;$&nbsp;curl&nbsp;127.0.0.1:9200 {&nbsp;&nbsp;"name"&nbsp;:&nbsp;"OfD9Jya",&nbsp;&nbsp;"cluster_name"&nbsp;:&nbsp;"elasticsearch",&nbsp;&nbsp;"cluster_uuid"&nbsp;:&nbsp;"_na_",&nbsp;&nbsp;"version"&nbsp;:&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"number"&nbsp;:&nbsp;"6.4.3",&nbsp;&nbsp;&nbsp;&nbsp;"build_flavor"&nbsp;:&nbsp;"default",&nbsp;&nbsp;&nbsp;&nbsp;"build_type"&nbsp;:&nbsp;"tar",&nbsp;&nbsp;&nbsp;&nbsp;"build_hash"&nbsp;:&nbsp;"fe40335",&nbsp;&nbsp;&nbsp;&nbsp;"build_date"&nbsp;:&nbsp;"2018-10-30T23:17:19.084789Z",&nbsp;&nbsp;&nbsp;&nbsp;"build_snapshot"&nbsp;:&nbsp;false,&nbsp;&nbsp;&nbsp;&nbsp;"lucene_version"&nbsp;:&nbsp;"7.4.0",&nbsp;&nbsp;&nbsp;&nbsp;"minimum_wire_compatibility_version"&nbsp;:&nbsp;"5.6.0",&nbsp;&nbsp;&nbsp;&nbsp;"minimum_index_compatibility_version"&nbsp;:&nbsp;"5.0.0"&nbsp;&nbsp;},&nbsp;&nbsp;"tagline"&nbsp;:&nbsp;"You&nbsp;Know,&nbsp;for&nbsp;Search"} 如上所示，启动成功 三.安装并启动kibana 下载安装包 &nbsp;$&nbsp;&nbsp;wget&nbsp;https://artifacts.elastic.co/downloads/kibana/kibana-6.4.3-darwin-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x86_64.tar.gz 解压 &nbsp;$&nbsp;mkdir&nbsp;/user/local/kibana&nbsp;$&nbsp;tar&nbsp;-zxvf&nbsp;kibana-6.4.3-darwin-x86_64.tar.gz&nbsp;-C&nbsp;/user/local/kibana 解压后的目录如下 ----bin----config----data----node----node_modules----optimize----... 进入 bin 目录启动 kibana &nbsp;$&nbsp;sh&nbsp;kibana 浏览器访问http://localhost:5601 看是否启动成功 四.安装并启动canal-server 下载安装包 &nbsp;$&nbsp;wget&nbsp;https://github.com/alibaba/canal/releases/download/canal-1.1.4/canal.deployer-1.1.4.tar.gz 解压 &nbsp;$&nbsp;mkdir&nbsp;/user/local/canal-server&nbsp;$&nbsp;tar&nbsp;-zxvf&nbsp;canal.deployer-1.1.4.tar.gz&nbsp;-C&nbsp;/user/local/canal-server 解压后的目录如下 ----bin----conf----lib----logs 3.修改配置 vim&nbsp;conf/example/instance.properties ###################################################&nbsp;mysql&nbsp;serverId&nbsp;,&nbsp;v1.0.26+&nbsp;will&nbsp;autoGen&nbsp;canal.instance.mysql.slaveId=1234#&nbsp;enable&nbsp;gtid&nbsp;use&nbsp;true/falsecanal.instance.gtidon=false#&nbsp;position&nbsp;infocanal.instance.master.address=127.0.0.1:3306canal.instance.master.journal.name=canal.instance.master.position=canal.instance.master.timestamp=canal.instance.master.gtid=#&nbsp;rds&nbsp;oss&nbsp;binlogcanal.instance.rds.accesskey=canal.instance.rds.secretkey=canal.instance.rds.instanceId=#&nbsp;table&nbsp;meta&nbsp;tsdb&nbsp;infocanal.instance.tsdb.enable=true#canal.instance.tsdb.url=jdbc:mysql://127.0.0.1:3306/canal_tsdb#canal.instance.tsdb.dbUsername=canal#canal.instance.tsdb.dbPassword=canal#canal.instance.standby.address&nbsp;=#canal.instance.standby.journal.name&nbsp;=#canal.instance.standby.position&nbsp;=#canal.instance.standby.timestamp&nbsp;=#canal.instance.standby.gtid=#&nbsp;username/passwordcanal.instance.dbUsername=rootcanal.instance.dbPassword=rootcanal.instance.connectionCharset&nbsp;=&nbsp;UTF-8#&nbsp;enable&nbsp;druid&nbsp;Decrypt&nbsp;database&nbsp;passwordcanal.instance.enableDruid=false#canal.instance.pwdPublicKey=MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALK4BUxdDltRRE5/zXpVEVPUgunvscYFtEip3pmLlhrWpacX7y7GCMo2/JM6LeHmiiNdH1FWgGCpUfircSwlWKUCAwEAAQ==#&nbsp;table&nbsp;regexcanal.instance.filter.regex=.*\\..*#&nbsp;table&nbsp;black&nbsp;regexcanal.instance.filter.black.regex=#&nbsp;table&nbsp;field&nbsp;filter(format:&nbsp;schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)#canal.instance.filter.field=test1.t_product:id/subject/keywords,test2.t_company:id/name/contact/ch#&nbsp;table&nbsp;field&nbsp;black&nbsp;filter(format:&nbsp;schema1.tableName1:field1/field2,schema2.tableName2:field1/field2)#canal.instance.filter.black.field=test1.t_product:subject/product_image,test2.t_company:id/name/contact/ch#&nbsp;mq&nbsp;configcanal.mq.topic=example#&nbsp;dynamic&nbsp;topic&nbsp;route&nbsp;by&nbsp;schema&nbsp;or&nbsp;table&nbsp;regex#canal.mq.dynamicTopic=mytest1.user,mytest2\\..*,.*\\..*canal.mq.partition=0#&nbsp;hash&nbsp;partition&nbsp;config#canal.mq.partitionsNum=3#canal.mq.partitionHash=test.table:id^name,.*\\..*################################################# 进入 bin 目录启动 canal-server &nbsp;$&nbsp;sh&nbsp;startup.sh 查看server日志 tail&nbsp;-200f&nbsp;logs/canal/canal.log 2019-11-12&nbsp;10:48:46.683&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;com.alibaba.otter.canal.deployer.CanalStarter&nbsp;-&nbsp;##&nbsp;start&nbsp;the&nbsp;canal&nbsp;server.2019-11-12&nbsp;10:48:46.733&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;com.alibaba.otter.canal.deployer.CanalController&nbsp;-&nbsp;##&nbsp;start&nbsp;the&nbsp;canal&nbsp;server[192.168.1.125(192.168.1.125):11111]2019-11-12&nbsp;10:48:48.842&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;com.alibaba.otter.canal.deployer.CanalStarter&nbsp;-&nbsp;##&nbsp;the&nbsp;canal&nbsp;server&nbsp;is&nbsp;running&nbsp;now&nbsp;...... 查看instance日志 tail&nbsp;-200f&nbsp;logs/example/example.log 2019-11-12&nbsp;10:48:47.650&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer&nbsp;-&nbsp;Loading&nbsp;properties&nbsp;file&nbsp;from&nbsp;class&nbsp;path&nbsp;resource&nbsp;[canal.properties]2019-11-12&nbsp;10:48:47.655&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;c.a.o.c.i.spring.support.PropertyPlaceholderConfigurer&nbsp;-&nbsp;Loading&nbsp;properties&nbsp;file&nbsp;from&nbsp;class&nbsp;path&nbsp;resource&nbsp;[example/instance.properties]2019-11-12&nbsp;10:48:48.508&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;c.a.otter.canal.instance.spring.CanalInstanceWithSpring&nbsp;-&nbsp;start&nbsp;CannalInstance&nbsp;for&nbsp;1-example2019-11-12&nbsp;10:48:48.530&nbsp;[main]&nbsp;WARN&nbsp;&nbsp;c.a.o.canal.parse.inbound.mysql.dbsync.LogEventConvert&nbsp;-&nbsp;--&gt;&nbsp;init&nbsp;table&nbsp;filter&nbsp;:&nbsp;^.*\..*$2019-11-12&nbsp;10:48:48.530&nbsp;[main]&nbsp;WARN&nbsp;&nbsp;c.a.o.canal.parse.inbound.mysql.dbsync.LogEventConvert&nbsp;-&nbsp;--&gt;&nbsp;init&nbsp;table&nbsp;black&nbsp;filter&nbsp;:2019-11-12&nbsp;10:48:48.672&nbsp;[destination&nbsp;=&nbsp;example&nbsp;,&nbsp;address&nbsp;=&nbsp;/127.0.0.1:3306&nbsp;,&nbsp;EventParser]&nbsp;WARN&nbsp;&nbsp;c.a.o.c.p.inbound.mysql.rds.RdsBinlogEventParserProxy&nbsp;-&nbsp;---&gt;&nbsp;begin&nbsp;to&nbsp;find&nbsp;start&nbsp;position,&nbsp;it&nbsp;will&nbsp;be&nbsp;long&nbsp;time&nbsp;for&nbsp;reset&nbsp;or&nbsp;first&nbsp;position2019-11-12&nbsp;10:48:48.782&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;c.a.otter.canal.instance.core.AbstractCanalInstance&nbsp;-&nbsp;start&nbsp;successful.... 五.安装并启动canal-adapter 1.基本说明client-adapter分为适配器和启动器两部分, 适配器为多个fat jar, 每个适配器会将自己所需的依赖打成一个包, 以SPI的方式让启动器动态加载, 目前所有支持的适配器都放置在plugin目录下 启动器为 SpringBoot 项目, 支持canal-client启动的同时提供相关REST管理接口, 运行目录结构为: -&nbsp;bin&nbsp;&nbsp;&nbsp;&nbsp;restart.sh&nbsp;&nbsp;&nbsp;&nbsp;startup.bat&nbsp;&nbsp;&nbsp;&nbsp;startup.sh&nbsp;&nbsp;&nbsp;&nbsp;stop.sh-&nbsp;lib&nbsp;&nbsp;&nbsp;...-&nbsp;plugin&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;client-adapter.logger-1.1.1-jar-with-dependencies.jar&nbsp;&nbsp;&nbsp;&nbsp;client-adapter.hbase-1.1.1-jar-with-dependencies.jar&nbsp;&nbsp;&nbsp;&nbsp;...-&nbsp;conf&nbsp;&nbsp;&nbsp;&nbsp;application.yml&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;hbase&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mytest_person2.yml-&nbsp;logs 以上目录结构最终会打包成 canal-adapter-*.tar.gz 压缩包 2.下载安装包 wget&nbsp;https://github.com/alibaba/canal/releases/download/canal-1.1.4/canal.adapter-1.1.4.tar.gz 解压 &nbsp;$&nbsp;mkdir&nbsp;/usr/local/canal-adapter&nbsp;$&nbsp;tar&nbsp;-zxvf&nbsp;canal.adapter-1.1.4.tar.gz&nbsp;-C&nbsp;/user/local/canal-adapter 解压后的目录如下 ----bin----conf----lib----logs 修改启动器配置: application.yml vim&nbsp;conf/application.yml server:&nbsp;&nbsp;port:&nbsp;8081spring:&nbsp;&nbsp;jackson:&nbsp;&nbsp;&nbsp;&nbsp;date-format:&nbsp;yyyy-MM-dd&nbsp;HH:mm:ss&nbsp;&nbsp;&nbsp;&nbsp;time-zone:&nbsp;GMT+8&nbsp;&nbsp;&nbsp;&nbsp;default-property-inclusion:&nbsp;non_nullcanal.conf:&nbsp;&nbsp;mode:&nbsp;tcp&nbsp;#&nbsp;kafka&nbsp;rocketMQ&nbsp;&nbsp;canalServerHost:&nbsp;127.0.0.1:11111#&nbsp;&nbsp;zookeeperHosts:&nbsp;slave1:2181#&nbsp;&nbsp;mqServers:&nbsp;127.0.0.1:9092&nbsp;#or&nbsp;rocketmq#&nbsp;&nbsp;flatMessage:&nbsp;true&nbsp;&nbsp;batchSize:&nbsp;500&nbsp;&nbsp;syncBatchSize:&nbsp;1000&nbsp;&nbsp;retries:&nbsp;0&nbsp;&nbsp;timeout:&nbsp;&nbsp;accessKey:&nbsp;&nbsp;secretKey:&nbsp;&nbsp;srcDataSources:&nbsp;&nbsp;&nbsp;&nbsp;defaultDS:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;url:&nbsp;jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;username:&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;password:&nbsp;root&nbsp;&nbsp;canalAdapters:&nbsp;&nbsp;-&nbsp;instance:&nbsp;example&nbsp;#&nbsp;canal&nbsp;instance&nbsp;Name&nbsp;or&nbsp;mq&nbsp;topic&nbsp;name&nbsp;&nbsp;&nbsp;&nbsp;groups:&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;groupId:&nbsp;g1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outerAdapters:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name:&nbsp;logger#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name:&nbsp;rdb#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key:&nbsp;mysql1#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;properties:#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdbc.driverClassName:&nbsp;com.mysql.jdbc.Driver#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdbc.url:&nbsp;jdbc:mysql://127.0.0.1:3306/mytest2?useUnicode=true#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdbc.username:&nbsp;root#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdbc.password:&nbsp;121212#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name:&nbsp;rdb#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key:&nbsp;oracle1#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;properties:#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdbc.driverClassName:&nbsp;oracle.jdbc.OracleDriver#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdbc.url:&nbsp;jdbc:oracle:thin:@localhost:49161:XE#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdbc.username:&nbsp;mytest#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdbc.password:&nbsp;m121212#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name:&nbsp;rdb#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;key:&nbsp;postgres1#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;properties:#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdbc.driverClassName:&nbsp;org.postgresql.Driver#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdbc.url:&nbsp;jdbc:postgresql://localhost:5432/postgres#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdbc.username:&nbsp;postgres#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jdbc.password:&nbsp;121212#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;threads:&nbsp;1#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;commitSize:&nbsp;3000#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name:&nbsp;hbase#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;properties:#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.zookeeper.quorum:&nbsp;127.0.0.1#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hbase.zookeeper.property.clientPort:&nbsp;2181#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zookeeper.znode.parent:&nbsp;/hbase&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;name:&nbsp;es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hosts:&nbsp;127.0.0.1:9200&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;properties:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode:&nbsp;rest&nbsp;#&nbsp;可指定transport模式或者rest模式&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;security.auth:&nbsp;test:123456&nbsp;#&nbsp;&nbsp;only&nbsp;used&nbsp;for&nbsp;rest&nbsp;mode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cluster.name:&nbsp;elasticsearch&nbsp;#&nbsp;es&nbsp;cluster&nbsp;name adapter将会自动加载 conf/es 下的所有.yml结尾的配置文件 修改适配器表映射文件 $&nbsp;vim&nbsp;conf/es/mytest_user.yml dataSourceKey:&nbsp;defaultDSdestination:&nbsp;examplegroupId:&nbsp;g1esMapping:&nbsp;&nbsp;_index:&nbsp;emp&nbsp;&nbsp;_type:&nbsp;_doc&nbsp;&nbsp;_id:&nbsp;_id&nbsp;&nbsp;upsert:&nbsp;true&nbsp;&nbsp;pk:&nbsp;_&nbsp;id&nbsp;&nbsp;sql:&nbsp;"SELECT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.id&nbsp;as&nbsp;_id,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.emp_name&nbsp;as&nbsp;empName,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.create_time&nbsp;as&nbsp;createTime,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.modify_time&nbsp;as&nbsp;modifyTime,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.department_id&nbsp;as&nbsp;departmentId,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.department_name&nbsp;as&nbsp;departmentName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FROM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;employee&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LEFT&nbsp;JOIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;department&nbsp;b&nbsp;on&nbsp;b.id&nbsp;=&nbsp;a.department_id"#&nbsp;&nbsp;objFields:#&nbsp;&nbsp;&nbsp;&nbsp;_labels:&nbsp;array:;&nbsp;&nbsp;etlCondition:&nbsp;"where&nbsp;a.create_time&gt;={}"&nbsp;&nbsp;commitBatch:&nbsp;3000 sql映射说明: sql支持多表关联自由组合, 但是有一定的限制: 主表不能为子查询语句 只能使用left outer join即最左表一定要是主表 关联从表如果是子查询不能有多张表 主sql中不能有where查询条件(从表子查询中可以有where条件但是不推荐, 可能会造成数据同步的不一致, 比如修改了where条件中的字段内容) 关联条件只允许主外键的'='操作不能出现其他常量判断比如: on a.role_id=b.id and b.statues=1 关联条件必须要有一个字段出现在主查询语句中比如: on a.role_id=b.id 其中的 a.role_id 或者 b.id 必须出现在主select语句中 Elastic Search的mapping 属性与sql的查询值将一一对应(不支持 select *), 比如: select a.id as _id, a.name, a.email as _email from user, 其中name将映射到es mapping的name field, _email将 映射到mapping的_email field, 这里以别名(如果有别名)作为最终的映射字段. 这里的_id可以填写到配置文件的 _id: _id映射. 创建两张表并插入数据，后面同步数据用 CREATE&nbsp;TABLE&nbsp;`employee`&nbsp;(&nbsp;&nbsp;`id`&nbsp;int(11)&nbsp;unsigned&nbsp;NOT&nbsp;NULL&nbsp;AUTO_INCREMENT&nbsp;COMMENT&nbsp;'自增ID',&nbsp;&nbsp;`is_deleted`&nbsp;tinyint(3)&nbsp;unsigned&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'是否删除（0:未删除&nbsp;1:已删除）',&nbsp;&nbsp;`create_time`&nbsp;datetime&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;CURRENT_TIMESTAMP&nbsp;COMMENT&nbsp;'记录创建时间',&nbsp;&nbsp;`modify_time`&nbsp;datetime&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;CURRENT_TIMESTAMP&nbsp;ON&nbsp;UPDATE&nbsp;CURRENT_TIMESTAMP&nbsp;COMMENT&nbsp;'记录修改时间',&nbsp;&nbsp;`creator`&nbsp;int(11)&nbsp;unsigned&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'创建人,0表示无创建人值',&nbsp;&nbsp;`modifier`&nbsp;int(11)&nbsp;unsigned&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'修改人,如果为0则表示纪录未修改',&nbsp;&nbsp;`emp_name`&nbsp;varchar(30)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;''&nbsp;COMMENT&nbsp;'员工姓名',&nbsp;&nbsp;`department_id`&nbsp;int(11)&nbsp;unsigned&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'部门ID',&nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(`id`))&nbsp;ENGINE=InnoDB&nbsp;DEFAULT&nbsp;CHARSET=utf8mb4&nbsp;COMMENT='员工' CREATE&nbsp;TABLE&nbsp;`department`&nbsp;(&nbsp;&nbsp;`id`&nbsp;int(11)&nbsp;unsigned&nbsp;NOT&nbsp;NULL&nbsp;AUTO_INCREMENT&nbsp;COMMENT&nbsp;'自增ID',&nbsp;&nbsp;`is_deleted`&nbsp;tinyint(3)&nbsp;unsigned&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'是否删除（0:未删除&nbsp;1:已删除）',&nbsp;&nbsp;`create_time`&nbsp;datetime&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;CURRENT_TIMESTAMP&nbsp;COMMENT&nbsp;'记录创建时间',&nbsp;&nbsp;`modify_time`&nbsp;datetime&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;CURRENT_TIMESTAMP&nbsp;ON&nbsp;UPDATE&nbsp;CURRENT_TIMESTAMP&nbsp;COMMENT&nbsp;'记录修改时间',&nbsp;&nbsp;`creator`&nbsp;int(11)&nbsp;unsigned&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'创建人,0表示无创建人值',&nbsp;&nbsp;`modifier`&nbsp;int(11)&nbsp;unsigned&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'修改人,如果为0则表示纪录未修改',&nbsp;&nbsp;`department_name`&nbsp;varchar(30)&nbsp;NOT&nbsp;NULL&nbsp;DEFAULT&nbsp;''&nbsp;COMMENT&nbsp;'部门名称',&nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(`id`))&nbsp;ENGINE=InnoDB&nbsp;DEFAULT&nbsp;CHARSET=utf8mb4&nbsp;COMMENT='部门'; INSERT&nbsp;INTO&nbsp;`employee`（`emp_name`,`department_id`）&nbsp;VALUES&nbsp;(&nbsp;'小明',&nbsp;1);INSERT&nbsp;INTO&nbsp;`employee`（`emp_name`,`department_id`）&nbsp;VALUES&nbsp;(&nbsp;'小红',&nbsp;2); INSERT&nbsp;INTO&nbsp;`department`（`department_name`）&nbsp;VALUES&nbsp;(&nbsp;'技术部');INSERT&nbsp;INTO&nbsp;`department`（`department_name`）&nbsp;VALUES&nbsp;(&nbsp;'业务部'); 同步数据前需先创建好该索引对应的mapping，否则会报错 打开kibana，localhost:5601，进入dev Tools PUT&nbsp;emp{&nbsp;&nbsp;&nbsp;&nbsp;"mappings":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_doc":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"properties":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"id":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"long"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"createTime":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"date"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"modifyTime":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"date"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"empName":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"text"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"departmenId":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"long"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"departmenName":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"type":&nbsp;"text"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 查看是否创建成功 GET&nbsp;/_cat/indices 6.进入bin目录启动canal-adapter $&nbsp;sh&nbsp;startup.sh 查看日志 $&nbsp;tail&nbsp;-200f&nbsp;logs/adapter/adapter.log 2019-11-13&nbsp;14:19:19.338&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;c.a.otter.canal.client.adapter.support.ExtensionLoader&nbsp;-&nbsp;extension&nbsp;classpath&nbsp;dir:&nbsp;/private/tmp/canal.adapter-1.1.4/plugin2019-11-13&nbsp;14:19:19.365&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;c.a.o.canal.adapter.launcher.loader.CanalAdapterLoader&nbsp;-&nbsp;Load&nbsp;canal&nbsp;adapter:&nbsp;logger&nbsp;succeed2019-11-13&nbsp;14:19:19.368&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;c.a.o.canal.client.adapter.es.config.ESSyncConfigLoader&nbsp;-&nbsp;##&nbsp;Start&nbsp;loading&nbsp;es&nbsp;mapping&nbsp;config&nbsp;...2019-11-13&nbsp;14:19:19.473&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;c.a.o.canal.client.adapter.es.config.ESSyncConfigLoader&nbsp;-&nbsp;##&nbsp;ES&nbsp;mapping&nbsp;config&nbsp;loaded2019-11-13&nbsp;14:19:20.190&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;c.a.o.canal.adapter.launcher.loader.CanalAdapterLoader&nbsp;-&nbsp;Load&nbsp;canal&nbsp;adapter:&nbsp;es&nbsp;succeed2019-11-13&nbsp;14:19:20.202&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;c.a.o.canal.adapter.launcher.loader.CanalAdapterLoader&nbsp;-&nbsp;Start&nbsp;adapter&nbsp;for&nbsp;canal&nbsp;instance:&nbsp;example&nbsp;succeed2019-11-13&nbsp;14:19:20.203&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;c.a.o.canal.adapter.launcher.loader.CanalAdapterService&nbsp;-&nbsp;##&nbsp;the&nbsp;canal&nbsp;client&nbsp;adapters&nbsp;are&nbsp;running&nbsp;now&nbsp;......2019-11-13&nbsp;14:19:20.221&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;org.apache.coyote.http11.Http11NioProtocol&nbsp;-&nbsp;Starting&nbsp;ProtocolHandler&nbsp;["http-nio-8081"]2019-11-13&nbsp;14:19:20.254&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;org.apache.tomcat.util.net.NioSelectorPool&nbsp;-&nbsp;Using&nbsp;a&nbsp;shared&nbsp;selector&nbsp;for&nbsp;servlet&nbsp;write/read2019-11-13&nbsp;14:19:20.277&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;o.s.boot.web.embedded.tomcat.TomcatWebServer&nbsp;-&nbsp;Tomcat&nbsp;started&nbsp;on&nbsp;port(s):&nbsp;8081&nbsp;(http)&nbsp;with&nbsp;context&nbsp;path&nbsp;''2019-11-13&nbsp;14:19:20.288&nbsp;[main]&nbsp;INFO&nbsp;&nbsp;c.a.otter.canal.adapter.launcher.CanalAdapterApplication&nbsp;-&nbsp;Started&nbsp;CanalAdapterApplication&nbsp;in&nbsp;6.224&nbsp;seconds&nbsp;(JVM&nbsp;running&nbsp;for&nbsp;6.838)2019-11-13&nbsp;14:19:21.203&nbsp;[Thread-4]&nbsp;INFO&nbsp;&nbsp;c.a.o.canal.adapter.launcher.loader.CanalAdapterWorker&nbsp;-&nbsp;=============&gt;&nbsp;Start&nbsp;to&nbsp;connect&nbsp;destination:&nbsp;example&nbsp;&lt;=============2019-11-13&nbsp;14:19:21.337&nbsp;[Thread-4]&nbsp;INFO&nbsp;&nbsp;c.a.o.canal.adapter.launcher.loader.CanalAdapterWorker&nbsp;-&nbsp;=============&gt;&nbsp;Start&nbsp;to&nbsp;subscribe&nbsp;destination:&nbsp;example&nbsp;&lt;=============2019-11-13&nbsp;14:19:21.344&nbsp;[Thread-4]&nbsp;INFO&nbsp;&nbsp;c.a.o.canal.adapter.launcher.loader.CanalAdapterWorker&nbsp;-&nbsp;=============&gt;&nbsp;Subscribe&nbsp;destination:&nbsp;example&nbsp;succeed&nbsp;&lt;============= 六.全量、增量同步数据到ES canal除了能实现自动增量同步数据的功能外还具有etl的功能其同步的实现细节会根据数据量的大小自动采用多线程进行同步，也是采用的游标的方式进行查询的，在提高了性能的同时也确保了不容易发生oom 全量同步（etl功能，手动触发） canal提供了一些接口，其中有一个用于全量同步数据的接口，我们发送一个请求即可 $&nbsp;curl&nbsp;http://127.0.0.1:8081/etl/es/mytest_person2.yml&nbsp;-X&nbsp;POST 若打印log {"succeeded":true,"resultMessage":"导入ES&nbsp;数据：2&nbsp;条"} 表示全量同步成功 若想增加限制条件同步，则在URL后加上对应的参数就可以了，其参数由es的配置项决定的，也就是上面配置文件中的etlCondition，比如我这里写的where a.create_time&gt;={}，而{}之内的就是条件 $&nbsp;curl&nbsp;http://127.0.0.1:8081/etl/es/mytest_person2.yml&nbsp;-X&nbsp;POST&nbsp;-d&nbsp;“params=2019-08-31&nbsp;00:00:00” 我们去kibana中看一下ES导入的数据 GET&nbsp;/emp/_search&nbsp; {&nbsp;&nbsp;"took":&nbsp;1,&nbsp;&nbsp;"timed_out":&nbsp;false,&nbsp;&nbsp;"_shards":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"total":&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;"successful":&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;"skipped":&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;"failed":&nbsp;0&nbsp;&nbsp;},&nbsp;&nbsp;"hits":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"total":&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;"max_score":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;"hits":&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_index":&nbsp;"emp",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_type":&nbsp;"_doc",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_id":&nbsp;"2",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_score":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_source":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"empName":&nbsp;"小红",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"createTime":&nbsp;"2019-11-12T14:26:45+08:00",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"modifyTime":&nbsp;"2019-11-14T16:56:43+08:00",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"departmentId":&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"departmentName":&nbsp;"业务部"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_index":&nbsp;"emp",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_type":&nbsp;"_doc",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_id":&nbsp;"1",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_score":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_source":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"empName":&nbsp;"小明",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"createTime":&nbsp;"2019-11-12T10:52:03+08:00",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"modifyTime":&nbsp;"2019-11-14T16:56:09+08:00",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"departmentId":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"departmentName":&nbsp;"技术部"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;}} MySql的两条数据已经导入到ES中 增量同步 canal增量同步是通过监听mysql的binlog进行实现的，那么当数据表里的内容有变化时canal client就会从canal server处获取到监听的内容。 下面我们来测试一下 新增数据 INSERT&nbsp;INTO&nbsp;`employee`（`emp_name`,`department_id`）&nbsp;VALUES&nbsp;(&nbsp;'小文',&nbsp;1); 查看ES GET&nbsp;/emp/_search {&nbsp;&nbsp;"took":&nbsp;1,&nbsp;&nbsp;"timed_out":&nbsp;false,&nbsp;&nbsp;"_shards":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"total":&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;"successful":&nbsp;5,&nbsp;&nbsp;&nbsp;&nbsp;"skipped":&nbsp;0,&nbsp;&nbsp;&nbsp;&nbsp;"failed":&nbsp;0&nbsp;&nbsp;},&nbsp;&nbsp;"hits":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"total":&nbsp;3,&nbsp;&nbsp;&nbsp;&nbsp;"max_score":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;"hits":&nbsp;[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_index":&nbsp;"emp",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_type":&nbsp;"_doc",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_id":&nbsp;"2",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_score":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_source":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"empName":&nbsp;"小红",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"createTime":&nbsp;"2019-11-12T14:26:45+08:00",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"modifyTime":&nbsp;"2019-11-14T16:56:43+08:00",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"departmentId":&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"departmentName":&nbsp;"业务部"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_index":&nbsp;"emp",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_type":&nbsp;"_doc",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_id":&nbsp;"1",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_score":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_source":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"empName":&nbsp;"小明",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"createTime":&nbsp;"2019-11-12T10:52:03+08:00",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"modifyTime":&nbsp;"2019-11-14T16:56:09+08:00",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"departmentId":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"departmentName":&nbsp;"技术部"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_index":&nbsp;"emp",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_type":&nbsp;"_doc",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_id":&nbsp;"3",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_score":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"_source":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"empName":&nbsp;"小文",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"createTime":&nbsp;"2019-11-14T17:14:20+08:00",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"modifyTime":&nbsp;"2019-11-14T17:14:39+08:00",&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"departmentId":&nbsp;1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"departmentName":&nbsp;"技术部"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;]&nbsp;&nbsp;}} 修改数据 将小文的部门改为业务部 UPDATE&nbsp;`employee`&nbsp;SET&nbsp;`department_id`&nbsp;=&nbsp;2&nbsp;WHERE&nbsp;id&nbsp;=&nbsp;3 查看ES GET&nbsp;/emp/_doc/3 {&nbsp;&nbsp;"_index":&nbsp;"emp",&nbsp;&nbsp;"_type":&nbsp;"_doc",&nbsp;&nbsp;"_id":&nbsp;"3",&nbsp;&nbsp;"_version":&nbsp;4,&nbsp;&nbsp;"found":&nbsp;true,&nbsp;&nbsp;"_source":&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;"empName":&nbsp;"小文",&nbsp;&nbsp;&nbsp;&nbsp;"createTime":&nbsp;"2019-11-14T17:14:20+08:00",&nbsp;&nbsp;&nbsp;&nbsp;"modifyTime":&nbsp;"2019-11-14T17:18:50+08:00",&nbsp;&nbsp;&nbsp;&nbsp;"departmentId":&nbsp;2,&nbsp;&nbsp;&nbsp;&nbsp;"departmentName":&nbsp;"业务部"&nbsp;&nbsp;}} 发现小文的部门已经变成了业务部 删除数据 将小文的部门改为业务部 DELETED&nbsp;FROM&nbsp;`employee`&nbsp;WHERE&nbsp;id&nbsp;=&nbsp;3 查看ES GET&nbsp;/emp/_doc/3 {&nbsp;&nbsp;"_index":&nbsp;"emp",&nbsp;&nbsp;"_type":&nbsp;"_doc",&nbsp;&nbsp;"_id":&nbsp;"3",&nbsp;&nbsp;"found":&nbsp;false} 删除成功 至此，我们完成了基于Canal实现MySql到ES数据全量与增量的同步**。本次的多表映射使用的是left join，下期将采用父子文档的形式，实现多表映射 敬请期待。 小贴士： 父子文档： 父子文档关联类似于join的操作，通过建立索引的时候描述文档之间的关系 父子关系文档在实质上类似于 nested model ：允许将一个对象实体和另外一个对象实体关联起来。而这两种类型的主要区别是：在 nested objects 文档中，所有对象都是在同一个文档中，而在父子关系文档中，父对象和子对象都是完全独立的文档。 父子关系的主要作用是允许把一个 type 的文档和另外一个 type 的文档关联起来，构成一对多的关系：一个父文档可以对应多个子文档 。与 nested objects 相比，父子关系的主要优势有： 更新父文档时，不会重新索引子文档。 创建，修改或删除子文档时，不会影响父文档或其他子文档。这一点在这种场景下尤其有用：子文档数量较多，并且子文档创建和修改的频率高时。 子文档可以作为搜索结果独立返回。Elasticsearch 维护了一个父文档和子文档的映射关系，得益于这个映射，父子文档关联查询操作非常快。但是这个映射也对父子文档关系有个限制条件：父文档和其所有子文档，都必须要存储在同一个分片中。 父子文档ID映射存储在 Doc Values 中。当映射完全在内存中时， Doc Values 提供对映射的快速处理能力，另一方面当映射非常大时，可以通过溢出到磁盘提供足够的扩展能力]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>Canal</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存相关问题]]></title>
    <url>%2F2019%2F04%2F28%2F4.%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.前言 在我们的平常的项目中多多少少都会使用到缓存，因为一些数据我们没有必要每次查询的时候都去查询到数据库。特别是高QPS的系统，每次都去查询数据库，对于你的数据库来说将是灾难。 今天我们不牵涉多级缓存的知识，就把系统使用到的缓存方案，不管是一级还是多级的都统称为缓存，主要是为了讲述使用缓存的时候可能会遇到的一些问题以及一些解决办法。我们使用缓存时，我们的逻辑是这样的： 当我们查询一条数据时，先去查询缓存，如果缓存有就直接返回，如果没有就去查询数据库，然后返回。这种情况下就可能会出现一些现象。 2.缓存穿透 2.1 什么是缓存穿透 正常情况下，我们去查询数据都是存在。 那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。 这种查询不存在数据的现象我们称为缓存穿透。 2.2 缓存穿透带来的问题 试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。 2.3 解决办法 2.3.1 缓存空值 之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。那么我们就可以为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null 。 这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间。 2.3.2 BloomFilterBloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中。 这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。 这种方案可以加在第一种方案中，在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -&gt; 查 DB。 2.4 如何选择 针对于一些恶意攻击，攻击带过来的大量key是不存在的，那么我们采用第一种方案就会缓存大量不存在key的数据。 此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些key。 针对这种key异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。 3. 缓存击穿 3.1 什么是缓存击穿 缓存击穿是我们可能遇到的第二个使用缓存方案可能遇到的问题。 在平常高并发的系统中，大量的请求同时查询一个key时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。 3.2 会带来什么问题 会造成某一时刻数据库请求量过大，压力剧增。 3.3 如何解决 上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。 其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。 4.缓存雪崩 4.1 什么是缓存雪崩 缓存雪崩的情况是说，当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉。 4.2 解决办法 4.2.1 事前： 使用集群缓存，保证缓存服务的高可用 这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。 4.2.2 事中： ehcache本地缓存 + Hystrix限流&amp;降级,避免MySQL被打死 使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。 使用Hystrix进行限流&amp;降级，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的3000请求就会走限流逻辑。然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。 4.2.3 事后： 开启Redis持久化机制，尽快恢复缓存集群 一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。 5 解决热点数据集中失效问题 我们在设置缓存的时候，一般会给缓存设置一个失效时间，过了这个时间，缓存就失效了 。对于一些热点的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况。 5.1 解决办法 5.1.1 设置不同的失效时间 为了避免这些热点的数据集中失效，那么我们在设置缓存过期时间的时候，我们让他们失效的时间错开。 比如在一个基础的时间上加上或者减去一个范围内的随机值。 5.1.2 互斥锁 结合上面的击穿的情况，在第一个请求去查询数据库的时候对他加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，从而保护数据库。 但是也是由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8日期时间处理总结]]></title>
    <url>%2F2019%2F04%2F15%2F3.Java8%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[示例： 示例1:Java 8中获取今天的日期 示例2:Java 8中获取年、月、日信息 示例3:Java 8中处理特定日期 示例4:Java 8中判断两个日期是否相等 示例5:Java 8中检查像生日这种周期性事件 示例6:Java 8中获取当前时间 示例7:Java 8中获取当前时间 示例8:Java 8如何计算一周后的日期 示例9:Java 8计算一年前或一年后的日期 示例10:Java 8的Clock时钟类 示例11:如何用Java判断日期是早于还是晚于另一个日期 示例12:Java 8中处理时区 示例13:如何表示信用卡到期这类固定日期，答案就在YearMonth 示例14:如何在Java 8中检查闰年 示例15:计算两个日期之间的天数和月数 示例16:在Java 8中获取当前的时间戳 示例17:Java 8中如何使用预定义的格式化工具去解析或格式化日期 示例18:字符串互转日期类型 Java 8 日期处理 Java 8 推出了全新的日期时间API，在教程中我们将通过一些简单的实例来学习如何使用新API。 Java处理日期、日历和时间的方式一直为社区所诟病，将 java.util.Date设定为可变类型，以及SimpleDateFormat的非线程安全使其应用非常受限。 新API基于ISO标准日历系统，java.time包下的所有类都是不可变类型而且线程安全。 编号 类的名称 描述 1 Instant 时间戳 2 Duration 持续时间，时间差 3 LocalDate 只包含日期，比如：2018-02-05 4 LocalTime 只包含时间，比如：23:12:10 5 LocalDateTime 包含日期和时间，比如：2018-02-05 23:14:21 6 Period 时间段 7 ZoneOffset 时区偏移量，比如：+8:00 8 ZonedDateTime 带时区的时间 9 Clock 时钟，比如获取目前美国纽约的时间 10 java.time.format.DateTimeFormatter 时间格式化 示例1:Java 8中获取今天的日期 Java 8 中的 LocalDate 用于表示当天日期。和java.util.Date不同，它只有日期，不包含时间。当你仅需要表示日期时就用这个类。 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDate;publicclass&nbsp;Demo01&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;today&nbsp;=&nbsp;LocalDate.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("今天的日期:"+today);&nbsp;&nbsp;&nbsp;&nbsp;}}/*&nbsp;&nbsp;&nbsp;&nbsp;运行结果:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天的日期:2018-02-05*/ 示例2:Java 8中获取年、月、日信息 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDate;publicclass&nbsp;Demo02&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;today&nbsp;=&nbsp;LocalDate.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;year&nbsp;=&nbsp;today.getYear();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;month&nbsp;=&nbsp;today.getMonthValue();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;day&nbsp;=&nbsp;today.getDayOfMonth();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("year:"+year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("month:"+month);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("day:"+day);&nbsp;&nbsp;&nbsp;&nbsp;}} 示例3:Java 8中处理特定日期 我们通过静态工厂方法now()非常容易地创建了当天日期，你还可以调用另一个有用的工厂方法LocalDate.of()创建任意日期， 该方法需要传入年、月、日做参数，返回对应的LocalDate实例。这个方法的好处是没再犯老API的设计错误，比如年度起始于1900，月份是从0开 始等等。 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDate;publicclass&nbsp;Demo03&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;date&nbsp;=&nbsp;LocalDate.of(2018,2,6);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("自定义日期:"+date);&nbsp;&nbsp;&nbsp;&nbsp;}} 示例4:Java 8中判断两个日期是否相等 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDate;publicclass&nbsp;Demo04&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;date1&nbsp;=&nbsp;LocalDate.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;date2&nbsp;=&nbsp;LocalDate.of(2018,2,5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(date1.equals(date2)){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("时间相等");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("时间不等");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 示例5:Java 8中检查像生日这种周期性事件 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDate;import&nbsp;java.time.MonthDay;publicclass&nbsp;Demo05&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;date1&nbsp;=&nbsp;LocalDate.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;date2&nbsp;=&nbsp;LocalDate.of(2018,2,6);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MonthDay&nbsp;birthday&nbsp;=&nbsp;MonthDay.of(date2.getMonth(),date2.getDayOfMonth());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MonthDay&nbsp;currentMonthDay&nbsp;=&nbsp;MonthDay.from(date1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(currentMonthDay.equals(birthday)){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("是你的生日");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("你的生日还没有到");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 只要当天的日期和生日匹配，无论是哪一年都会打印出祝贺信息。你可以把程序整合进系统时钟，看看生日时是否会受到提醒，或者写一个单元测试来检测代码是否运行正确。 示例6:Java 8中获取当前时间 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalTime;publicclass&nbsp;Demo06&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalTime&nbsp;time&nbsp;=&nbsp;LocalTime.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("获取当前的时间,不含有日期:"+time);&nbsp;&nbsp;&nbsp;&nbsp;}} 可以看到当前时间就只包含时间信息，没有日期 示例7:Java 8中获取当前时间 通过增加小时、分、秒来计算将来的时间很常见。Java 8除了不变类型和线程安全的好处之外，还提供了更好的plusHours()方法替换add()，并且是兼容的。注意，这些方法返回一个全新的LocalTime实例，由于其不可变性，返回后一定要用变量赋值。 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalTime;publicclass&nbsp;Demo07&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalTime&nbsp;time&nbsp;=&nbsp;LocalTime.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalTime&nbsp;newTime&nbsp;=&nbsp;time.plusHours(3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("三个小时后的时间为:"+newTime);&nbsp;&nbsp;&nbsp;&nbsp;}} 示例8:Java 8如何计算一周后的日期 和上个例子计算3小时以后的时间类似，这个例子会计算一周后的日期。LocalDate日期不包含时间信息，它的plus()方法用来增加天、周、月，ChronoUnit类声明了这些时间单位。由于LocalDate也是不变类型，返回后一定要用变量赋值。 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDate;import&nbsp;java.time.temporal.ChronoUnit;publicclass&nbsp;Demo08&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;today&nbsp;=&nbsp;LocalDate.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("今天的日期为:"+today);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;nextWeek&nbsp;=&nbsp;today.plus(1,&nbsp;ChronoUnit.WEEKS);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("一周后的日期为:"+nextWeek);&nbsp;&nbsp;&nbsp;&nbsp;}} 可以看到新日期离当天日期是7天，也就是一周。你可以用同样的方法增加1个月、1年、1小时、1分钟甚至一个世纪，更多选项可以查看Java 8 API中的ChronoUnit类 示例9:Java 8计算一年前或一年后的日期 利用minus()方法计算一年前的日期 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDate;import&nbsp;java.time.temporal.ChronoUnit;publicclass&nbsp;Demo09&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;today&nbsp;=&nbsp;LocalDate.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;previousYear&nbsp;=&nbsp;today.minus(1,&nbsp;ChronoUnit.YEARS);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("一年前的日期&nbsp;:&nbsp;"&nbsp;+&nbsp;previousYear);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;nextYear&nbsp;=&nbsp;today.plus(1,&nbsp;ChronoUnit.YEARS);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("一年后的日期:"+nextYear);&nbsp;&nbsp;&nbsp;&nbsp;}} 示例10:Java 8的Clock时钟类 Java 8增加了一个Clock时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到System.currentTimeInMillis()和TimeZone.getDefault()的地方都可用Clock替换。 package&nbsp;com.shxt.demo02;import&nbsp;java.time.Clock;publicclass&nbsp;Demo10&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Returns&nbsp;the&nbsp;current&nbsp;time&nbsp;based&nbsp;on&nbsp;your&nbsp;system&nbsp;clock&nbsp;and&nbsp;set&nbsp;to&nbsp;UTC.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clock&nbsp;clock&nbsp;=&nbsp;Clock.systemUTC();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Clock&nbsp;:&nbsp;"&nbsp;+&nbsp;clock.millis());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Returns&nbsp;time&nbsp;based&nbsp;on&nbsp;system&nbsp;clock&nbsp;zone&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clock&nbsp;defaultClock&nbsp;=&nbsp;Clock.systemDefaultZone();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Clock&nbsp;:&nbsp;"&nbsp;+&nbsp;defaultClock.millis());&nbsp;&nbsp;&nbsp;&nbsp;}} 示例11:如何用Java判断日期是早于还是晚于另一个日期 另一个工作中常见的操作就是如何判断给定的一个日期是大于某天还是小于某天？在Java 8中，LocalDate类有两类方法isBefore()和isAfter()用于比较日期。 调用isBefore()方法时，如果给定日期小于当前日期则返回true。 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDate;import&nbsp;java.time.temporal.ChronoUnit;publicclass&nbsp;Demo11&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;today&nbsp;=&nbsp;LocalDate.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;tomorrow&nbsp;=&nbsp;LocalDate.of(2018,2,6);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(tomorrow.isAfter(today)){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("之后的日期:"+tomorrow);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;yesterday&nbsp;=&nbsp;today.minus(1,&nbsp;ChronoUnit.DAYS);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(yesterday.isBefore(today)){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("之前的日期:"+yesterday);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 示例12:Java 8中处理时区 Java 8不仅分离了日期和时间，也把时区分离出来了。现在有一系列单独的类如ZoneId来处理特定时区，ZoneDateTime类来表示某时区下的时间。这在Java 8以前都是 GregorianCalendar类来做的。下面这个例子展示了如何把本时区的时间转换成另一个时区的时间。 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDateTime;import&nbsp;java.time.ZoneId;import&nbsp;java.time.ZonedDateTime;publicclass&nbsp;Demo12&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Date&nbsp;and&nbsp;time&nbsp;with&nbsp;timezone&nbsp;in&nbsp;Java&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZoneId&nbsp;america&nbsp;=&nbsp;ZoneId.of("America/New_York");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDateTime&nbsp;localtDateAndTime&nbsp;=&nbsp;LocalDateTime.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZonedDateTime&nbsp;dateAndTimeInNewYork&nbsp;&nbsp;=&nbsp;ZonedDateTime.of(localtDateAndTime,&nbsp;america&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Current&nbsp;date&nbsp;and&nbsp;time&nbsp;in&nbsp;a&nbsp;particular&nbsp;timezone&nbsp;:&nbsp;"&nbsp;+&nbsp;dateAndTimeInNewYork);&nbsp;&nbsp;&nbsp;&nbsp;}} 示例13:如何表示信用卡到期这类固定日期，答案就在YearMonth 与 MonthDay检查重复事件的例子相似，YearMonth是另一个组合类，用于表示信用卡到期日、FD到期日、期货期权到期日等。还可以用这个类得到 当月共有多少天，YearMonth实例的lengthOfMonth()方法可以返回当月的天数，在判断2月有28天还是29天时非常有用。 package&nbsp;com.shxt.demo02;import&nbsp;java.time.*;publicclass&nbsp;Demo13&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YearMonth&nbsp;currentYearMonth&nbsp;=&nbsp;YearMonth.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.printf("Days&nbsp;in&nbsp;month&nbsp;year&nbsp;%s:&nbsp;%d%n",&nbsp;currentYearMonth,&nbsp;currentYearMonth.lengthOfMonth());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;YearMonth&nbsp;creditCardExpiry&nbsp;=&nbsp;YearMonth.of(2019,&nbsp;Month.FEBRUARY);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.printf("Your&nbsp;credit&nbsp;card&nbsp;expires&nbsp;on&nbsp;%s&nbsp;%n",&nbsp;creditCardExpiry);&nbsp;&nbsp;&nbsp;&nbsp;}} 示例14:如何在Java 8中检查闰年 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDate;publicclass&nbsp;Demo14&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;today&nbsp;=&nbsp;LocalDate.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(today.isLeapYear()){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("This&nbsp;year&nbsp;is&nbsp;Leap&nbsp;year");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("2018&nbsp;is&nbsp;not&nbsp;a&nbsp;Leap&nbsp;year");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}} 示例15:计算两个日期之间的天数和月数 有一个常见日期操作是计算两个日期之间的天数、周数或月数。在Java 8中可以用java.time.Period类来做计算。下面这个例子中，我们计算了当天和将来某一天之间的月数。 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDate;import&nbsp;java.time.Period;publicclass&nbsp;Demo15&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;today&nbsp;=&nbsp;LocalDate.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;java8Release&nbsp;=&nbsp;LocalDate.of(2018,&nbsp;12,&nbsp;14);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Period&nbsp;periodToNextJavaRelease&nbsp;=&nbsp;Period.between(today,&nbsp;java8Release);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Months&nbsp;left&nbsp;between&nbsp;today&nbsp;and&nbsp;Java&nbsp;8&nbsp;release&nbsp;:&nbsp;"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+&nbsp;periodToNextJavaRelease.getMonths()&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;}} 示例16:在Java 8中获取当前的时间戳 Instant类有一个静态工厂方法now()会返回当前的时间戳，如下所示： package&nbsp;com.shxt.demo02;import&nbsp;java.time.Instant;publicclass&nbsp;Demo16&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instant&nbsp;timestamp&nbsp;=&nbsp;Instant.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("What&nbsp;is&nbsp;value&nbsp;of&nbsp;this&nbsp;instant&nbsp;"&nbsp;+&nbsp;timestamp.toEpochMilli());&nbsp;&nbsp;&nbsp;&nbsp;}} 时间戳信息里同时包含了日期和时间，这和java.util.Date很像。实际上Instant类确实等同于 Java 8之前的Date类，你可以使用Date类和Instant类各自的转换方法互相转换 例如：Date.from(Instant) 将Instant转换成java.util.Date，Date.toInstant()则是将Date类转换成Instant类。 示例17:Java 8中如何使用预定义的格式化工具去解析或格式化日期 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDate;import&nbsp;java.time.format.DateTimeFormatter;publicclass&nbsp;Demo17&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;dayAfterTommorrow&nbsp;=&nbsp;"20180205";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;formatted&nbsp;=&nbsp;LocalDate.parse(dayAfterTommorrow,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DateTimeFormatter.BASIC_ISO_DATE);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(dayAfterTommorrow+"&nbsp;&nbsp;格式化后的日期为:&nbsp;&nbsp;"+formatted);&nbsp;&nbsp;&nbsp;&nbsp;}} 示例18:字符串互转日期类型 package&nbsp;com.shxt.demo02;import&nbsp;java.time.LocalDate;import&nbsp;java.time.LocalDateTime;import&nbsp;java.time.format.DateTimeFormatter;publicclass&nbsp;Demo18&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDateTime&nbsp;date&nbsp;=&nbsp;LocalDateTime.now();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DateTimeFormatter&nbsp;format1&nbsp;=&nbsp;DateTimeFormatter.ofPattern("yyyy/MM/dd&nbsp;HH:mm:ss");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//日期转字符串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;str&nbsp;=&nbsp;date.format(format1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("日期转换为字符串:"+str);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DateTimeFormatter&nbsp;format2&nbsp;=&nbsp;DateTimeFormatter.ofPattern("yyyy/MM/dd&nbsp;HH:mm:ss");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//字符串转日期&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LocalDate&nbsp;date2&nbsp;=&nbsp;LocalDate.parse(str,format2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("日期类型:"+date2);&nbsp;&nbsp;&nbsp;&nbsp;}}]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql索引必须了解的几个重要问题]]></title>
    <url>%2F2019%2F03%2F11%2F2.mysql%E7%B4%A2%E5%BC%95%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%87%A0%E4%B8%AA%E9%87%8D%E8%A6%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、索引是干什么的？ 索引用于快速找出在某个列中有一特定值的行。不使用索引，mysql必须从第一条记录开始读完整个表直到找出相关的行。表越大，花费的时间越多。如果表中查询的列有一个索引，mysql能快速到达一个位置搜寻到数据文件的中间，没有必要查看所有数据。 大多数mysql的索引(primary key、index、unique、fulltext)在B树中存储，只是空间列类型的索引使用R树，并且memory表还支持hash索引。 2、索引好复杂，我该怎么理解索引，有没有一个更形象的例子？ 想象一下，你面前有本词典，数据就是书的正文内容，你就是那个cpu，而索引是书的目录。 3、索引越多越好？ 大多数情况下，索引能大幅提高查询效率。但是:数据变更(增删改)都需要维护索引，因此更多索引意味着更多维护成本；也意味着需要更多控件空间(一本书100页，却有50页目录？)；过小的表，建索引可能会更慢(读2页的宣传手册，你还需要先去找目录？) 4、索引的字段类型问题 text类型，也可建索引(需要指定长度)；mysiam存储引擎长度综合不能超过1000字节；用来筛选的值尽量保持和索引列同样的数据类型。 5、like能用到索引？ 尽量减少like查询，但是也不是绝对不可用，xxx%是可以用到索引的。除了like，以下操作符也可以用到索引： &lt;，&lt;=，=，&gt;，&gt;=，between，in 这些用不到索引： &lt;&gt;，not in，!= 6、什么样的字段不适合建索引？ 列的值唯一性太小(比如性别，类型)，不适合建索引。(什么叫大小？一般来说，同值的数据超过表的15%，那就没有必要建索引了) 更新非常频繁的数据不适合建索引。 7、一次查询能用多个索引？ 不能 8、多列查询该如何建索引？ 一次查询只能用到一个索引， a列建索引还是b列建索引？谁的区分度（同值的少）更高，建谁！ 当然，联合索引也是个不错的方案。 9、联合索引的问题 where a = 'xxx'可以使用ab联合索引；where b = 'xxx'则不能命中ab联合索引。 所以大多数情况下，有ab索引了，就不用再去建a索引了。 10、哪些常见的情况不能用到索引？ like '%xxx'，not in，!= 对列进行函数运算，如： where md5(password) = "xxx" 存了数值的字符串类型字段(如手机号)，查询是记得不要丢掉值的引号，否则无法命中索引： select * from test where mobile = 13800002222; 如果mobile字段是char或者varchar类型，则上面查询无法命中索引。 11、NULL的问题 Null会导致索引形同虚设，所以在设计表结构应避免NULL的存在。可用其他方式来表达，比如-1。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F01%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[探究：Spring事务传播行为]]></title>
    <url>%2F2019%2F01%2F28%2F1.%E6%8E%A2%E7%A9%B6%EF%BC%9ASpring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%2F</url>
    <content type="text"><![CDATA[前言 Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。这是Spring为我们提供的强大的工具箱，使用事务传播行为可以为我们的开发工作提供许多便利。但是人们对他的误解也颇多，你一定也听过“service方法事务最好不要嵌套”的传言。要想正确的使用工具首先需要了解工具。本文对七种事务传播行为做详细介绍，内容主要代码示例的方式呈现。 基础概念 1.什么是事务传播行为 事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。 伪代码描述： public&nbsp;void&nbsp;methodA(){&nbsp;&nbsp;&nbsp;&nbsp;methodB();&nbsp;&nbsp;&nbsp;&nbsp;//doSomething&nbsp;}&nbsp;@Transaction(Propagation=XXX)&nbsp;public&nbsp;void&nbsp;methodB(){&nbsp;&nbsp;&nbsp;&nbsp;//doSomething&nbsp;} 代码中methodA()方法嵌套调用了methodB()方法，methodB()的事务传播行为由@Transaction(Propagation=XXX)设置决定。这里需要注意的是methodA()并没有开启事务，某一个事务传播行为修饰的方法并不是必须要在开启事务的外围方法中调用。 2.Spring中七种事务传播行为 事务传播行为类型 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。（默认值） PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 下面我们进入代码测试阶段 代码验证 文中代码以传统三层结构中两层呈现，即Service和Dao层，由Spring负责依赖注入和注解式事务管理，DAO层由Mybatis实现，数据库使用的是MySQL数据库，你也可以使用任何支持事务的数据库，并不会影响验证结果。 1.PROPAGATION_REQUIRED 我们为UserService和User2Service相应方法加上Propagation.REQUIRED属性。 @Servicepublic&nbsp;class&nbsp;UserServiceImpl&nbsp;implements&nbsp;UserService&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;UserMapper&nbsp;userMapper;&nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;addRequired(UserDO&nbsp;user)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userMapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;}}@Servicepublic&nbsp;class&nbsp;User2ServiceImpl&nbsp;implements&nbsp;User2Service&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;User2Mapper&nbsp;user2Mapper;&nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;addRequired(User2DO&nbsp;user)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Mapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;addRequiredException(User2DO&nbsp;user)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Mapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException();&nbsp;&nbsp;&nbsp;&nbsp;}} 1.1场景一 此场景外部方法没有开启事务 demo_1 &nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addRequired(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequired(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException();&nbsp;&nbsp;&nbsp;&nbsp;} demo_2 &nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addRequired(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequiredException(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;} 测试结果： 案例 数据库结果 分析 demo_1 "测试01"、"测试02"均插入 外部方法未开启事务，插入"测试01"、"测试02"方法在自己的事务中独立运行，外部方法异常不影响内部插入"测试01"、"测试02"方法独立的事务。 demo_2 "测试01"插入、"测试02"未插入 外部方法没有事务，插入“测试01”、“测试02”方法都在自己的事务中独立运行,所以插入“测试02”方法抛出异常只会回滚插入“测试02”方法，插入“测试01”方法不受影响。 结论：通过这两个方法我们证明了在外部方法未开启事务的情况下Propagation.REQUIRED修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。 1.2场景二 外部方法开启事务，这个是使用率比较高的场景。 demo_3: &nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addRequired(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequired(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException();&nbsp;&nbsp;&nbsp;&nbsp;} demo_4 &nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addRequired(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequiredException(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;} demo_5 &nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addRequired(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequiredException(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("异常");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;} 测试结果： 案例 数据库结果 分析 demo_3 "测试01"、"测试02"均未插入 外部方法开启事务，内部方法加入外部方法事务，外围方法回滚，内部方法也要回滚。 demo_4 "测试01"、"测试02"均未插入 外部方法开启事务，内部方法加入外部方法事务，内部方法抛出异常回滚，外部方法感知异常致使整体事务回滚。 demo_5 "测试01"、"测试02"均未插入 外部方法开启事务，内部方法加入外部方法事务，内部方法抛出异常回滚，即使方法被catch不被外部方法感知，整个事务依然回滚。 结论：以上试验结果我们证明在外部方法开启事务的情况下Propagation.REQUIRED修饰的内部方法会加入到外部方法的事务中，所有Propagation.REQUIRED修饰的内部方法和外部方法均属于同一事务，只要一个方法回滚，整个事务均回滚。 2.PROPAGATION_REQUIRES_NEW 我们为UserService和User2Service相应方法加上Propagation.REQUIRES_NEW属性。 UserService @Servicepublic&nbsp;class&nbsp;UserServiceImpl&nbsp;implements&nbsp;UserService&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;UserMapper&nbsp;userMapper;&nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRES_NEW)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;addRequiredNew(UserDO&nbsp;user)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userMapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;addRequired(UserDO&nbsp;user)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userMapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;}} User2Service @Servicepublic&nbsp;class&nbsp;User2ServiceImpl&nbsp;implements&nbsp;User2Service&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;User2Mapper&nbsp;user2Mapper;&nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRES_NEW)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;addRequiredNew(User2DO&nbsp;user)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Mapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRES_NEW)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;addRequiredNewException(User2DO&nbsp;user)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Mapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException();&nbsp;&nbsp;&nbsp;&nbsp;}} 2.1场景一 外部方法没有开启事务。 demo_6 &nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addRequiredNew(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequiredNew(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException();&nbsp;&nbsp;&nbsp;&nbsp;} demo_7 &nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addRequiredNew(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequiredNewException(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;} 测试结果： 案例 数据库结果 分析 demo_6 "测试01"、"测试02"均插入 外部方法没有事务，插入“测试01”、“测试02”方法都在自己的事务中独立运行,外围方法抛出异常回滚不会影响内部方法。 demo_7 "测试01"插入、"测试02"未插入 外部方法没有开启事务，插入“测试01”方法和插入“测试02”方法分别开启自己的事务，插入“测试02”方法抛出异常回滚，其他事务不受影响。 结论：通过这两个方法我们证明了在外部方法未开启事务的情况下Propagation.REQUIRES_NEW修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。 2.2场景二 外围方法开启事务。 demo_8 &nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addRequired(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequiredNew(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequiredNew(User2DO.builder().userName("测试03").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException();&nbsp;&nbsp;&nbsp;&nbsp;} demo_9 &nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addRequired(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequiredNew(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequiredNewException(User2DO.builder().userName("测试03").build());&nbsp;&nbsp;&nbsp;&nbsp;} demo_10 &nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.REQUIRED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addRequired(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequiredNew(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addRequiredNewException(User2DO.builder().userName("测试03").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("异常");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;} 测试结果： 案例 数据库结果 分析 demo_8 "测试01"未插入、"测试02"、"测试03"均插入 外围方法开启事务，插入“测试01”方法和外部方法一个事务，插入“测试02”方法、插入“测试03”方法分别在独立的新建事务中，外围方法抛出异常只回滚和外围方法同一事务的方法，故插入“测试01”的方法回滚。 demo_9 "测试01"未插入，"测试02"插入，"测试03"未插入。 外部方法开启事务，插入"测试01"方法和外围方法一个事务，插入"测试02"方法、插入"测试03"方法分别在独立的新建事务中。插入"测试03"方法抛出异常，首先插入 "测试03"方法的事务被回滚，异常继续抛出被外围方法感知，外围方法事务亦被回滚，故插入"测试01"方法也被回滚。 demo_10 "测试01"插入，"测试02"插入，"测试03"未插入。 外部方法开启事务，插入"测试01"方法和外部方法一个事务，插入"测试02"方法、插入"测试03"方法分别在独立的新建事务中。插入"测试03"方法抛出异常，首先插入"测试03"方法的事务被回滚，异常被catch不会被外部方法感知，外部方法事务不回滚，故插入"测试01"方法插入成功。 结论：在外部方法开启事务的情况下，Propagation.REQUIRES_NEW修饰的内部方法依然会单独开启独立事务，且与外部方法事务也独立，内部方法之间、内部方法和外部方法事务均相互独立，互不干扰。 3.PROPAGATION_NESTED 我们为UserService和User2Service相应方法加上Propagation.NESTED属性。 UserService @Servicepublic&nbsp;class&nbsp;UserServiceImpl&nbsp;implements&nbsp;UserService&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;UserMapper&nbsp;userMapper;&nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.NESTED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;addNested(UserDO&nbsp;user)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userMapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;}} User2Service @Servicepublic&nbsp;class&nbsp;User2ServiceImpl&nbsp;implements&nbsp;User2Service&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;User2Mapper&nbsp;user2Mapper;&nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.NESTED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;addNested(User2DO&nbsp;user)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Mapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.NESTED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;addNestedException(User2DO&nbsp;user)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Mapper.insertSelective(user);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException();&nbsp;&nbsp;&nbsp;&nbsp;}} 3.1场景一 外部方法没有开启事务。 demo_11 &nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addNested(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addNested(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException();&nbsp;&nbsp;&nbsp;&nbsp;} demo_12 &nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addNested(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addNestedException(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;} 测试结果： 案例 数据库结果 分析 demo_11 "测试01"、"测试02"均插入 外部方法没有事务，插入“测试01”、“测试02”方法都在自己的事务中独立运行,外围方法抛出异常回滚不会影响内部方法。 demo_12 "测试01"插入、"测试02"未插入 外部方法没有开启事务，插入“测试01”方法和插入“测试02”方法分别开启自己的事务，插入“测试02”方法抛出异常回滚，其他事务不受影响。 结论：通过这两个方法我们证明了在外围方法未开启事务的情况下Propagation.NESTED和Propagation.REQUIRED、Propagation.REQUIRED_NEW作用相同，修饰的内部方法都会新开启自己的事务，且开启的事务相互独立，互不干扰。 3.2场景二 外方法开启事务。 demo_13 &nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.NESTED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addNested(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addNested(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException();&nbsp;&nbsp;&nbsp;&nbsp;} demo_14 &nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.NESTED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addNested(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addNestedException(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;} demo_15 &nbsp;&nbsp;&nbsp;&nbsp;@Transactional(rollbackFor&nbsp;=&nbsp;Exception.class,&nbsp;propagation&nbsp;=&nbsp;Propagation.NESTED)&nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;test()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userService.addNested(UserDO.builder().userName("测试01").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;user2Service.addNestedException(User2DO.builder().userName("测试02").build());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("异常");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;} 测试结果： 案例 数据库结果 分析 demo_13 "测试01"、"测试02"均未插入 外部方法开启事务，内部事务为外围事务的子事务，外围方法回滚，内部方法也要回滚。 demo_9 "测试01"、"测试02"均未插入 外部方法开启事务，内部事务为外部事务的子事务，内部方法抛出异常回滚，且外部方法感知异常致使整体事务回滚。 demo_10 "测试01"插入，"测试02"未插入 外部方法开启事务，内部事务为外部事务的子事务，插入“张三”内部方法抛出异常，可以单独对子事务回滚。 结论：以上试验结果我们证明在外部方法开启事务的情况下Propagation.NESTED修饰的内部方法属于外部事务的子事务，外部主事务回滚，子事务一定回滚，而内部子事务可以单独回滚而不影响外部主事务和其他子事务。 4. REQUIRED,REQUIRES_NEW,NESTED异同 由“1.2 场景二”和“3.2 场景二”对比，我们可知：NESTED和REQUIRED修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。但是REQUIRED是加入外围方法事务，所以和外围事务同属于一个事务，一旦REQUIRED事务抛出异常被回滚，外围方法事务也将被回滚。而NESTED是外围方法的子事务，有单独的保存点，所以NESTED方法抛出异常被回滚，不会影响到外围方法的事务。 由“2.2 场景二”和“3.2 场景二”对比，我们可知：NESTED和REQUIRES_NEW都可以做到内部方法事务回滚而不影响外围方法事务。但是因为NESTED是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。而REQUIRES_NEW是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
